import 'package:fluttron_cli/src/generate/parsed_contract.dart';

/// Generator for Host-side service implementation code.
///
/// Takes a [ParsedServiceContract] and generates a Dart file with:
/// - An abstract `Base` class extending `FluttronService`
/// - `switch/case` routing in the `handle` method
/// - Parameter extraction and validation
/// - Abstract method signatures for user implementation
/// - Helper methods for common validation patterns
class HostServiceGenerator {
  /// Creates a [HostServiceGenerator] with optional configuration.
  const HostServiceGenerator({
    this.generatedBy = 'fluttron generate services',
    this.sourceFile,
  });

  /// The tool name to include in the generated header.
  final String generatedBy;

  /// The source file path to include in the generated header.
  final String? sourceFile;

  /// Generates the Host-side Dart code for the given [contract].
  ///
  /// The generated code is an abstract class named `{ClassName}Base`
  /// that extends `FluttronService` and contains:
  /// - The `namespace` getter
  /// - The `handle` method with `switch/case` routing
  /// - Abstract method declarations for each service method
  /// - Helper methods for parameter validation
  String generate(ParsedServiceContract contract) {
    final buffer = StringBuffer();

    // Write header
    _writeHeader(buffer, contract);

    // Write imports
    _writeImports(buffer);

    // Write class declaration
    _writeClassDeclaration(buffer, contract);

    // Write namespace getter
    _writeNamespaceGetter(buffer, contract);

    // Write handle method
    _writeHandleMethod(buffer, contract);

    // Write abstract method declarations
    _writeAbstractMethods(buffer, contract);

    // Write helper methods
    _writeHelperMethods(buffer, contract);

    // Close class
    buffer.writeln('}');

    return buffer.toString();
  }

  void _writeHeader(StringBuffer buffer, ParsedServiceContract contract) {
    buffer.writeln('// GENERATED CODE â€” DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by: $generatedBy');
    if (sourceFile != null) {
      buffer.writeln('// Source: $sourceFile');
    }
    buffer.writeln('// Timestamp: ${DateTime.now().toUtc().toIso8601String()}');
    buffer.writeln();
  }

  void _writeImports(StringBuffer buffer) {
    buffer.writeln("import 'package:fluttron_host/fluttron_host.dart';");
    buffer.writeln("import 'package:fluttron_shared/fluttron_shared.dart';");
    buffer.writeln();
  }

  void _writeClassDeclaration(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    buffer.writeln('/// Base class with routing logic.');
    buffer.writeln('/// Extend this class to provide method implementations.');
    buffer.writeln(
      'abstract class ${contract.className}Base extends FluttronService {',
    );
  }

  void _writeNamespaceGetter(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    buffer.writeln('  @override');
    buffer.writeln("  String get namespace => '${contract.namespace}';");
    buffer.writeln();
  }

  void _writeHandleMethod(StringBuffer buffer, ParsedServiceContract contract) {
    buffer.writeln('  @override');
    buffer.writeln(
      '  Future<dynamic> handle(String method, Map<String, dynamic> params) async {',
    );
    buffer.writeln('    switch (method) {');

    for (final method in contract.methods) {
      _writeSwitchCase(buffer, contract, method);
    }

    // Write default case
    buffer.writeln('      default:');
    buffer.writeln("        throw FluttronError(");
    buffer.writeln("          'METHOD_NOT_FOUND',");
    buffer.writeln(
      "          '${contract.namespace}.\$method not implemented',",
    );
    buffer.writeln('        );');

    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln();
  }

  void _writeSwitchCase(
    StringBuffer buffer,
    ParsedServiceContract contract,
    ParsedMethod method,
  ) {
    buffer.writeln("      case '${method.name}':");

    // Extract parameters
    final paramExtractions = <String>[];
    final paramNames = <String>[];

    for (final param in method.parameters) {
      final extractionCode = _generateParamExtraction(param);
      if (extractionCode != null) {
        paramExtractions.add(extractionCode);
      }
      paramNames.add(_getParamPassName(param));
    }

    // Write parameter extraction
    for (final extraction in paramExtractions) {
      buffer.writeln('        $extraction');
    }

    // Write method call
    buffer.write('        ');
    final innerType = method.returnType.innerType;
    if (innerType != null && !innerType.isVoid) {
      buffer.write('final result = ');
    }
    buffer.write('await ${method.name}(${paramNames.join(', ')}');
    buffer.writeln(');');

    // Write return serialization
    _writeReturnSerialization(buffer, method);

    buffer.writeln();
  }

  String? _generateParamExtraction(ParsedParameter param) {
    final type = param.type;

    // For optional named parameters with default values
    if (param.isNamed && param.hasDefaultValue) {
      return _generateOptionalParamWithDefault(param);
    }

    // For nullable optional named parameters
    if (param.isNamed && type.isNullable) {
      return _generateNullableOptionalParam(param);
    }

    // For nullable positional parameters (type is nullable but param is required)
    // Treat them as allowing null
    if (!param.isNamed && type.isNullable && param.isRequired) {
      return _generateNullablePositionalParam(param);
    }

    // For required parameters
    if (param.isRequired) {
      return _generateRequiredParamExtraction(param);
    }

    // For optional parameters without default (nullable)
    if (!param.isRequired) {
      return _generateOptionalParamWithoutDefault(param);
    }

    return null;
  }

  String _generateNullablePositionalParam(ParsedParameter param) {
    final type = param.type;
    final name = param.name;

    if (type.isBasicType) {
      final baseType = type.baseName;
      if (baseType == 'String') {
        return "final $name = params['$name'] as String?;";
      } else if (baseType == 'int') {
        return "final $name = params['$name'] as int?;";
      } else if (baseType == 'double') {
        return "final $name = (params['$name'] as num?)?.toDouble();";
      } else if (baseType == 'bool') {
        return "final $name = params['$name'] as bool?;";
      } else if (baseType == 'DateTime') {
        return "final $name = params['$name'] != null ? DateTime.parse(params['$name'] as String) : null;";
      }
    }

    if (type.isList) {
      return "final $name = params['$name'] as List<dynamic>?;";
    }
    if (type.isMap) {
      return "final $name = params['$name'] as Map<String, dynamic>?;";
    }

    return "final $name = params['$name'];";
  }

  String _generateRequiredParamExtraction(ParsedParameter param) {
    final type = param.type;
    final name = param.name;

    // Handle basic types
    if (type.isBasicType) {
      final baseType = type.baseName;
      if (baseType == 'String') {
        return "final $name = _requireString(params, '$name');";
      } else if (baseType == 'int') {
        return "final $name = _requireInt(params, '$name');";
      } else if (baseType == 'double') {
        return "final $name = _requireDouble(params, '$name');";
      } else if (baseType == 'bool') {
        return "final $name = _requireBool(params, '$name');";
      } else if (baseType == 'num') {
        return "final $name = _requireNum(params, '$name');";
      } else if (baseType == 'DateTime') {
        return "final $name = _requireDateTime(params, '$name');";
      }
    }

    // Handle List types
    if (type.isList) {
      final innerType = type.innerType;
      if (innerType != null && innerType.isBasicType) {
        return "final $name = _requireList(params, '$name');";
      } else {
        // List of custom models - just get the list
        return "final $name = _requireList(params, '$name');";
      }
    }

    // Handle Map types
    if (type.isMap) {
      return "final $name = _requireMap(params, '$name');";
    }

    // For custom model types, use fromMap to convert
    return "final $name = ${type.displayName}.fromMap(Map<String, dynamic>.from(params['$name'] as Map));";
  }

  String _generateOptionalParamWithDefault(ParsedParameter param) {
    final type = param.type;
    final name = param.name;
    final defaultValue = param.defaultValue;

    // Handle basic types with defaults
    if (type.isBasicType) {
      final baseType = type.baseName;
      if (baseType == 'String') {
        return "final $name = params['$name'] as String? ?? $defaultValue;";
      } else if (baseType == 'int') {
        return "final $name = params['$name'] as int? ?? $defaultValue;";
      } else if (baseType == 'double') {
        return "final $name = (params['$name'] as num?)?.toDouble() ?? $defaultValue;";
      } else if (baseType == 'bool') {
        return "final $name = params['$name'] as bool? ?? $defaultValue;";
      }
    }

    // Handle List/Map with defaults
    if (type.isList) {
      return "final $name = (params['$name'] as List<dynamic>?) ?? $defaultValue;";
    }
    if (type.isMap) {
      return "final $name = (params['$name'] as Map<String, dynamic>?) ?? $defaultValue;";
    }

    // Default fallback
    return "final $name = params['$name'] ?? $defaultValue;";
  }

  String _generateNullableOptionalParam(ParsedParameter param) {
    final type = param.type;
    final name = param.name;

    if (type.isBasicType) {
      final baseType = type.baseName;
      if (baseType == 'String') {
        return "final $name = params['$name'] as String?;";
      } else if (baseType == 'int') {
        return "final $name = params['$name'] as int?;";
      } else if (baseType == 'double') {
        return "final $name = (params['$name'] as num?)?.toDouble();";
      } else if (baseType == 'bool') {
        return "final $name = params['$name'] as bool?;";
      } else if (baseType == 'DateTime') {
        return "final $name = params['$name'] != null ? DateTime.parse(params['$name'] as String) : null;";
      }
    }

    if (type.isList) {
      return "final $name = params['$name'] as List<dynamic>?;";
    }
    if (type.isMap) {
      return "final $name = params['$name'] as Map<String, dynamic>?;";
    }

    return "final $name = params['$name'];";
  }

  String _generateOptionalParamWithoutDefault(ParsedParameter param) {
    final type = param.type;
    final name = param.name;

    if (type.isBasicType) {
      return "final $name = params['$name'] as ${type.displayName}?;";
    }

    return "final $name = params['$name'];";
  }

  String _getParamPassName(ParsedParameter param) {
    if (param.isNamed) {
      return '${param.name}: ${param.name}';
    }
    return param.name;
  }

  void _writeReturnSerialization(StringBuffer buffer, ParsedMethod method) {
    final returnType = method.returnType.innerType;
    if (returnType == null || returnType.isVoid) {
      // void return - return empty map
      buffer.writeln("        return {};");
      return;
    }

    // Handle basic return types wrapped in a map
    if (returnType.isBasicType && !returnType.isList && !returnType.isMap) {
      buffer.writeln("        return {'result': result};");
      return;
    }

    // Handle List types
    if (returnType.isList) {
      final innerType = returnType.innerType;
      if (innerType != null && innerType.isBasicType) {
        // List of basic types - return as-is
        buffer.writeln('        return result;');
      } else {
        // List of models - map toMap
        buffer.writeln('        return result.map((e) => e.toMap()).toList();');
      }
      return;
    }

    // Handle Map types
    if (returnType.isMap) {
      buffer.writeln('        return result;');
      return;
    }

    // Handle custom model types
    buffer.writeln('        return result.toMap();');
  }

  void _writeAbstractMethods(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    for (final method in contract.methods) {
      // Write documentation if available
      if (method.documentation != null) {
        for (final line in method.documentation!.split('\n')) {
          buffer.writeln('  /// $line');
        }
      }
      buffer.writeln('  /// Override to implement: ${method.name}.');
      buffer.write('  ${_generateMethodSignature(method)};\n');
      buffer.writeln();
    }
  }

  String _generateMethodSignature(ParsedMethod method) {
    final buffer = StringBuffer();

    // Return type
    buffer.write('${method.returnType.displayName} ');

    // Method name
    buffer.write(method.name);

    // Parameters
    buffer.write('(');

    final positionalParams = method.parameters
        .where((p) => !p.isNamed)
        .toList();
    final namedParams = method.parameters.where((p) => p.isNamed).toList();

    // Positional parameters
    for (var i = 0; i < positionalParams.length; i++) {
      final param = positionalParams[i];
      buffer.write('${param.type.displayName} ${param.name}');
      if (i < positionalParams.length - 1 || namedParams.isNotEmpty) {
        buffer.write(', ');
      }
    }

    // Named parameters
    if (namedParams.isNotEmpty) {
      buffer.write('{');
      for (var i = 0; i < namedParams.length; i++) {
        final param = namedParams[i];
        buffer.write('${param.type.displayName} ${param.name}');
        if (param.hasDefaultValue) {
          buffer.write(' = ${param.defaultValue}');
        }
        if (i < namedParams.length - 1) {
          buffer.write(', ');
        }
      }
      buffer.write('}');
    }

    buffer.write(')');

    return buffer.toString();
  }

  void _writeHelperMethods(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    // Determine which helpers are needed based on method signatures
    final neededHelpers = <String>{};

    for (final method in contract.methods) {
      for (final param in method.parameters) {
        if (param.isRequired && param.type.isBasicType) {
          final baseType = param.type.baseName;
          if (baseType == 'String') {
            neededHelpers.add('_requireString');
          } else if (baseType == 'int') {
            neededHelpers.add('_requireInt');
          } else if (baseType == 'double') {
            neededHelpers.add('_requireDouble');
          } else if (baseType == 'bool') {
            neededHelpers.add('_requireBool');
          } else if (baseType == 'num') {
            neededHelpers.add('_requireNum');
          } else if (baseType == 'DateTime') {
            neededHelpers.add('_requireDateTime');
          }
        }
        if (param.isRequired && (param.type.isList || param.type.isMap)) {
          if (param.type.isList) {
            neededHelpers.add('_requireList');
          }
          if (param.type.isMap) {
            neededHelpers.add('_requireMap');
          }
        }
      }
    }

    if (neededHelpers.contains('_requireString')) {
      buffer.writeln('''
  String _requireString(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is String && v.isNotEmpty) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireInt')) {
      buffer.writeln('''
  int _requireInt(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is int) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireDouble')) {
      buffer.writeln('''
  double _requireDouble(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is num) return v.toDouble();
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireBool')) {
      buffer.writeln('''
  bool _requireBool(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is bool) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireNum')) {
      buffer.writeln('''
  num _requireNum(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is num) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireDateTime')) {
      buffer.writeln('''
  DateTime _requireDateTime(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is String) {
      try {
        return DateTime.parse(v);
      } catch (_) {
        // Fall through to error
      }
    }
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireList')) {
      buffer.writeln('''
  List<dynamic> _requireList(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is List) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireMap')) {
      buffer.writeln('''
  Map<String, dynamic> _requireMap(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is Map<String, dynamic>) return v;
    if (v is Map) return Map<String, dynamic>.from(v);
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }
  }
}
