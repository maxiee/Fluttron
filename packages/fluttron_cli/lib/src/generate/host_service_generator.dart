import 'package:fluttron_cli/src/generate/parsed_contract.dart';

/// Generator for Host-side service implementation code.
///
/// Takes a [ParsedServiceContract] and generates a Dart file with:
/// - An abstract `Base` class extending `FluttronService`
/// - `switch/case` routing in the `handle` method
/// - Parameter extraction and validation
/// - Abstract method signatures for user implementation
/// - Helper methods for common validation patterns
class HostServiceGenerator {
  /// Creates a [HostServiceGenerator] with optional configuration.
  const HostServiceGenerator({
    this.generatedBy = 'fluttron generate services',
    this.sourceFile,
    this.additionalImports = const [],
  });

  /// The tool name to include in the generated header.
  final String generatedBy;

  /// The source file path to include in the generated header.
  final String? sourceFile;

  /// Additional import URIs required by generated code (for example models).
  final List<String> additionalImports;

  /// Generates the Host-side Dart code for the given [contract].
  ///
  /// The generated code is an abstract class named `{ClassName}Base`
  /// that extends `FluttronService` and contains:
  /// - The `namespace` getter
  /// - The `handle` method with `switch/case` routing
  /// - Abstract method declarations for each service method
  /// - Helper methods for parameter validation
  String generate(ParsedServiceContract contract) {
    final buffer = StringBuffer();

    // Write header
    _writeHeader(buffer, contract);

    // Write imports
    _writeImports(buffer);

    // Write class declaration
    _writeClassDeclaration(buffer, contract);

    // Write namespace getter
    _writeNamespaceGetter(buffer, contract);

    // Write handle method
    _writeHandleMethod(buffer, contract);

    // Write abstract method declarations
    _writeAbstractMethods(buffer, contract);

    // Write helper methods
    _writeHelperMethods(buffer, contract);

    // Close class
    buffer.writeln('}');

    return buffer.toString();
  }

  void _writeHeader(StringBuffer buffer, ParsedServiceContract contract) {
    buffer.writeln('// GENERATED CODE â€” DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by: $generatedBy');
    if (sourceFile != null) {
      buffer.writeln('// Source: $sourceFile');
    }
    buffer.writeln('// Timestamp: ${DateTime.now().toUtc().toIso8601String()}');
    buffer.writeln();
  }

  void _writeImports(StringBuffer buffer) {
    const baseImports = <String>[
      'package:fluttron_host/fluttron_host.dart',
      'package:fluttron_shared/fluttron_shared.dart',
    ];

    final seen = <String>{};
    for (final importUri in <String>[...baseImports, ...additionalImports]) {
      if (!seen.add(importUri)) {
        continue;
      }
      buffer.writeln("import '$importUri';");
    }
    buffer.writeln();
  }

  void _writeClassDeclaration(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    buffer.writeln('/// Base class with routing logic.');
    buffer.writeln('/// Extend this class to provide method implementations.');
    buffer.writeln(
      'abstract class ${contract.className}Base extends FluttronService {',
    );
  }

  void _writeNamespaceGetter(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    buffer.writeln('  @override');
    buffer.writeln("  String get namespace => '${contract.namespace}';");
    buffer.writeln();
  }

  void _writeHandleMethod(StringBuffer buffer, ParsedServiceContract contract) {
    buffer.writeln('  @override');
    buffer.writeln(
      '  Future<dynamic> handle(String method, Map<String, dynamic> params) async {',
    );
    buffer.writeln('    switch (method) {');

    for (final method in contract.methods) {
      _writeSwitchCase(buffer, contract, method);
    }

    // Write default case
    buffer.writeln('      default:');
    buffer.writeln("        throw FluttronError(");
    buffer.writeln("          'METHOD_NOT_FOUND',");
    buffer.writeln(
      "          '${contract.namespace}.\$method not implemented',",
    );
    buffer.writeln('        );');

    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln();
  }

  void _writeSwitchCase(
    StringBuffer buffer,
    ParsedServiceContract contract,
    ParsedMethod method,
  ) {
    buffer.writeln("      case '${method.name}':");

    // Extract parameters
    final paramExtractions = <String>[];
    final paramNames = <String>[];

    for (final param in method.parameters) {
      final extractionCode = _generateParamExtraction(param);
      if (extractionCode != null) {
        paramExtractions.add(extractionCode);
      }
      paramNames.add(_getParamPassName(param));
    }

    // Write parameter extraction
    for (final extraction in paramExtractions) {
      buffer.writeln('        $extraction');
    }

    // Write method call
    buffer.write('        ');
    final innerType = method.returnType.innerType;
    if (innerType != null && !innerType.isVoid) {
      buffer.write('final result = ');
    }
    buffer.write('await ${method.name}(${paramNames.join(', ')}');
    buffer.writeln(');');

    // Write return serialization
    _writeReturnSerialization(buffer, method);

    buffer.writeln();
  }

  String? _generateParamExtraction(ParsedParameter param) {
    if (param.hasDefaultValue) {
      return _generateOptionalParamWithDefault(param);
    }

    if (param.isRequired) {
      return _generateRequiredParamExtraction(param);
    }

    return _generateOptionalParamWithoutDefault(param);
  }

  String _generateRequiredParamExtraction(ParsedParameter param) {
    final type = param.type;
    final name = param.name;

    // Handle basic types with explicit validation helpers.
    if (type.isBasicType) {
      final baseType = type.baseName;
      if (baseType == 'String') {
        return "final $name = _requireString(params, '$name');";
      } else if (baseType == 'int') {
        return "final $name = _requireInt(params, '$name');";
      } else if (baseType == 'double') {
        return "final $name = _requireDouble(params, '$name');";
      } else if (baseType == 'bool') {
        return "final $name = _requireBool(params, '$name');";
      } else if (baseType == 'num') {
        return "final $name = _requireNum(params, '$name');";
      } else if (baseType == 'DateTime') {
        return "final $name = _requireDateTime(params, '$name');";
      }
    }

    if (type.isList) {
      final deserializeExpr = _deserializeFromTransportExpression(
        "_requireList(params, '$name')",
        type,
      );
      return "final $name = $deserializeExpr;";
    }

    if (type.isMap || _isCustomModelType(type)) {
      final deserializeExpr = _deserializeFromTransportExpression(
        "_requireMap(params, '$name')",
        type,
      );
      return "final $name = $deserializeExpr;";
    }

    return "final $name = params['$name'];";
  }

  String _generateOptionalParamWithDefault(ParsedParameter param) {
    final type = param.type;
    final name = param.name;
    final defaultValue = param.defaultValue;
    final sourceExpr = "params['$name']";
    final targetType = type.isNullable ? type.asNonNullable : type;
    final deserializeExpr = _deserializeFromTransportExpression(
      sourceExpr,
      targetType,
    );
    return "final $name = $sourceExpr == null ? $defaultValue : $deserializeExpr;";
  }

  String _generateOptionalParamWithoutDefault(ParsedParameter param) {
    final type = param.type;
    final name = param.name;
    final sourceExpr = "params['$name']";

    if (type.isNullable) {
      final deserializeExpr = _deserializeFromTransportExpression(
        sourceExpr,
        type.asNonNullable,
      );
      return "final $name = $sourceExpr == null ? null : $deserializeExpr;";
    }

    if (type.isBasicType) {
      final nullableTypeName = type.displayName.endsWith('?')
          ? type.displayName
          : '${type.displayName}?';
      return "final $name = $sourceExpr as $nullableTypeName;";
    }

    final deserializeExpr = _deserializeFromTransportExpression(
      sourceExpr,
      type,
    );
    return "final $name = $sourceExpr == null ? null : $deserializeExpr;";
  }

  String _getParamPassName(ParsedParameter param) {
    if (param.isNamed) {
      return '${param.name}: ${param.name}';
    }
    return param.name;
  }

  void _writeReturnSerialization(StringBuffer buffer, ParsedMethod method) {
    final returnType = method.returnType.innerType;
    if (returnType == null || returnType.isVoid) {
      // void return - return empty map
      buffer.writeln("        return {};");
      return;
    }

    if (returnType.isBasicType && !returnType.isList && !returnType.isMap) {
      final serializedResult = _serializeForTransportExpression(
        'result',
        returnType,
      );
      buffer.writeln("        return {'result': $serializedResult};");
      return;
    }

    // Preserve direct passthrough for non-nullable collections of JSON-primitive values.
    if (returnType.isList) {
      final innerType = returnType.innerType;
      final isPrimitiveList =
          innerType != null &&
          innerType.isBasicType &&
          innerType.baseName != 'DateTime' &&
          !innerType.isNullable;
      if (isPrimitiveList && !returnType.isNullable) {
        buffer.writeln('        return result;');
        return;
      }
    }

    final serializedResult = _serializeForTransportExpression(
      'result',
      returnType,
    );
    buffer.writeln('        return $serializedResult;');
  }

  String _serializeForTransportExpression(String valueExpr, ParsedType type) {
    if (type.isNullable) {
      return '$valueExpr == null ? null : '
          '${_serializeForTransportExpression(valueExpr, type.asNonNullable)}';
    }

    if (type.isBasicType) {
      if (type.baseName == 'DateTime') {
        return '$valueExpr.toIso8601String()';
      }
      return valueExpr;
    }

    if (type.isList) {
      final innerType = type.innerType;
      if (innerType == null) {
        return valueExpr;
      }
      final innerExpr = _serializeForTransportExpression('e', innerType);
      return '$valueExpr.map((e) => $innerExpr).toList()';
    }

    if (type.isMap || type.isDynamic) {
      if (type.isDynamic) {
        return valueExpr;
      }
      final valueType = type.typeArguments.length > 1
          ? type.typeArguments[1]
          : null;
      if (valueType == null || valueType.isDynamic) {
        return valueExpr;
      }
      final valueSerializeExpr = _serializeForTransportExpression(
        'v',
        valueType,
      );
      return '$valueExpr.map((k, v) => MapEntry(k, $valueSerializeExpr))';
    }

    return '$valueExpr.toMap()';
  }

  String _deserializeFromTransportExpression(
    String valueExpr,
    ParsedType type,
  ) {
    if (type.isNullable) {
      return '$valueExpr == null ? null : '
          '${_deserializeFromTransportExpression(valueExpr, type.asNonNullable)}';
    }

    if (type.isBasicType) {
      final baseType = type.baseName;
      if (baseType == 'String') {
        return '$valueExpr as String';
      } else if (baseType == 'int') {
        return '$valueExpr as int';
      } else if (baseType == 'double') {
        return '($valueExpr as num).toDouble()';
      } else if (baseType == 'bool') {
        return '$valueExpr as bool';
      } else if (baseType == 'num') {
        return '$valueExpr as num';
      } else if (baseType == 'DateTime') {
        return 'DateTime.parse($valueExpr as String)';
      }
    }

    if (type.isList) {
      final innerType = type.innerType;
      if (innerType == null) {
        return '$valueExpr as List<dynamic>';
      }
      final innerExpr = _deserializeFromTransportExpression('e', innerType);
      return '($valueExpr as List).map((e) => $innerExpr).toList()';
    }

    if (type.isMap) {
      final valueType = type.typeArguments.length > 1
          ? type.typeArguments[1]
          : null;
      final sourceMapExpr = 'Map<String, dynamic>.from($valueExpr as Map)';
      if (valueType == null || valueType.isDynamic) {
        return sourceMapExpr;
      }
      final valueDeserializeExpr = _deserializeFromTransportExpression(
        'v',
        valueType,
      );
      return '$sourceMapExpr.map((k, v) => MapEntry(k, $valueDeserializeExpr))';
    }

    if (type.isDynamic) {
      return valueExpr;
    }

    return '${type.baseName}.fromMap(Map<String, dynamic>.from($valueExpr as Map))';
  }

  bool _isCustomModelType(ParsedType type) {
    return !type.isBasicType &&
        !type.isList &&
        !type.isMap &&
        !type.isDynamic &&
        !type.isVoid;
  }

  void _writeAbstractMethods(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    for (final method in contract.methods) {
      // Write documentation if available
      if (method.documentation != null) {
        for (final line in method.documentation!.split('\n')) {
          buffer.writeln('  /// $line');
        }
      }
      buffer.writeln('  /// Override to implement: ${method.name}.');
      buffer.write('  ${_generateMethodSignature(method)};\n');
      buffer.writeln();
    }
  }

  String _generateMethodSignature(ParsedMethod method) {
    final buffer = StringBuffer();

    // Return type
    buffer.write('${method.returnType.displayName} ');

    // Method name
    buffer.write(method.name);

    // Parameters
    buffer.write('(');

    final requiredPositionalParams = method.parameters
        .where((p) => !p.isNamed && p.isRequired)
        .toList();
    final optionalPositionalParams = method.parameters
        .where((p) => !p.isNamed && !p.isRequired)
        .toList();
    final namedParams = method.parameters.where((p) => p.isNamed).toList();

    var needsSeparator = false;

    for (final param in requiredPositionalParams) {
      if (needsSeparator) {
        buffer.write(', ');
      }
      _writeParameterDeclaration(buffer, param);
      needsSeparator = true;
    }

    if (optionalPositionalParams.isNotEmpty) {
      if (needsSeparator) {
        buffer.write(', ');
      }
      buffer.write('[');
      for (var i = 0; i < optionalPositionalParams.length; i++) {
        _writeParameterDeclaration(buffer, optionalPositionalParams[i]);
        if (i < optionalPositionalParams.length - 1) {
          buffer.write(', ');
        }
      }
      buffer.write(']');
      needsSeparator = true;
    }

    if (namedParams.isNotEmpty) {
      if (needsSeparator) {
        buffer.write(', ');
      }
      buffer.write('{');
      for (var i = 0; i < namedParams.length; i++) {
        _writeParameterDeclaration(buffer, namedParams[i]);
        if (i < namedParams.length - 1) {
          buffer.write(', ');
        }
      }
      buffer.write('}');
    }

    buffer.write(')');

    return buffer.toString();
  }

  void _writeParameterDeclaration(
    StringBuffer buffer,
    ParsedParameter parameter,
  ) {
    if (parameter.isNamed &&
        parameter.isRequired &&
        !parameter.hasDefaultValue) {
      buffer.write('required ');
    }

    buffer.write('${parameter.type.displayName} ${parameter.name}');
    if (parameter.hasDefaultValue) {
      buffer.write(' = ${parameter.defaultValue}');
    }
  }

  void _writeHelperMethods(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    // Determine which helpers are needed based on method signatures
    final neededHelpers = <String>{};

    for (final method in contract.methods) {
      for (final param in method.parameters) {
        if (param.isRequired && param.type.isBasicType) {
          final baseType = param.type.baseName;
          if (baseType == 'String') {
            neededHelpers.add('_requireString');
          } else if (baseType == 'int') {
            neededHelpers.add('_requireInt');
          } else if (baseType == 'double') {
            neededHelpers.add('_requireDouble');
          } else if (baseType == 'bool') {
            neededHelpers.add('_requireBool');
          } else if (baseType == 'num') {
            neededHelpers.add('_requireNum');
          } else if (baseType == 'DateTime') {
            neededHelpers.add('_requireDateTime');
          }
        }
        if (param.isRequired && (param.type.isList || param.type.isMap)) {
          if (param.type.isList) {
            neededHelpers.add('_requireList');
          }
          if (param.type.isMap) {
            neededHelpers.add('_requireMap');
          }
        }
        if (param.isRequired && _isCustomModelType(param.type)) {
          neededHelpers.add('_requireMap');
        }
      }
    }

    if (neededHelpers.contains('_requireString')) {
      buffer.writeln('''
  String _requireString(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is String && v.isNotEmpty) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireInt')) {
      buffer.writeln('''
  int _requireInt(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is int) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireDouble')) {
      buffer.writeln('''
  double _requireDouble(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is num) return v.toDouble();
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireBool')) {
      buffer.writeln('''
  bool _requireBool(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is bool) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireNum')) {
      buffer.writeln('''
  num _requireNum(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is num) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireDateTime')) {
      buffer.writeln('''
  DateTime _requireDateTime(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is String) {
      try {
        return DateTime.parse(v);
      } catch (_) {
        // Fall through to error
      }
    }
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireList')) {
      buffer.writeln('''
  List<dynamic> _requireList(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is List) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }

    if (neededHelpers.contains('_requireMap')) {
      buffer.writeln('''
  Map<String, dynamic> _requireMap(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is Map<String, dynamic>) return v;
    if (v is Map) return Map<String, dynamic>.from(v);
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "\$key"');
  }
''');
    }
  }
}
