import 'package:fluttron_cli/src/generate/parsed_contract.dart';

/// Generator for model class serialization code.
///
/// Takes a [ParsedModel] and generates a Dart file with:
/// - A complete model class with all fields
/// - A `fromMap()` factory constructor for deserialization
/// - A `toMap()` method for serialization
class ModelGenerator {
  /// Creates a [ModelGenerator] with optional configuration.
  const ModelGenerator({
    this.generatedBy = 'fluttron generate services',
    this.sourceFile,
  });

  /// The tool name to include in the generated header.
  final String generatedBy;

  /// The source file path to include in the generated header.
  final String? sourceFile;

  /// Generates the model Dart code for the given [model].
  ///
  /// The generated code is a class with:
  /// - All fields from the parsed model
  /// - A const constructor
  /// - A `fromMap()` factory for deserialization from JSON
  /// - A `toMap()` method for serialization to JSON
  String generate(ParsedModel model) {
    final buffer = StringBuffer();

    // Write header
    _writeHeader(buffer);

    // Write class documentation
    _writeClassDocumentation(buffer, model);

    // Write class declaration
    _writeClassDeclaration(buffer, model);

    // Write fields
    _writeFields(buffer, model);

    // Write constructor
    _writeConstructor(buffer, model);

    // Write fromMap factory
    _writeFromMapFactory(buffer, model);

    // Write toMap method
    _writeToMapMethod(buffer, model);

    // Close class
    buffer.writeln('}');

    return buffer.toString();
  }

  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// GENERATED CODE â€” DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by: $generatedBy');
    if (sourceFile != null) {
      buffer.writeln('// Source: $sourceFile');
    }
    buffer.writeln('// Timestamp: ${DateTime.now().toUtc().toIso8601String()}');
    buffer.writeln();
  }

  void _writeClassDocumentation(StringBuffer buffer, ParsedModel model) {
    if (model.documentation != null) {
      for (final line in model.documentation!.split('\n')) {
        buffer.writeln('/// $line');
      }
    }
  }

  void _writeClassDeclaration(StringBuffer buffer, ParsedModel model) {
    buffer.writeln('class ${model.className} {');
  }

  void _writeFields(StringBuffer buffer, ParsedModel model) {
    for (final field in model.fields) {
      // Write field documentation if available
      if (field.documentation != null) {
        for (final line in field.documentation!.split('\n')) {
          buffer.writeln('  /// $line');
        }
      }
      buffer.writeln('  final ${field.type.displayName} ${field.name};');
    }
    buffer.writeln();
  }

  void _writeConstructor(StringBuffer buffer, ParsedModel model) {
    buffer.writeln('  const ${model.className}({');

    for (final field in model.fields) {
      final isNullable = field.type.isNullable;
      if (!isNullable) {
        buffer.writeln('    required this.${field.name},');
      } else {
        buffer.writeln('    this.${field.name},');
      }
    }

    buffer.writeln('  });');
    buffer.writeln();
  }

  void _writeFromMapFactory(StringBuffer buffer, ParsedModel model) {
    buffer.writeln(
      '  factory ${model.className}.fromMap(Map<String, dynamic> map) {',
    );
    buffer.writeln('    return ${model.className}(');

    for (final field in model.fields) {
      final deserializeExpr = _deserializeFromMapExpression(
        "map['${field.name}']",
        field.type,
      );
      buffer.writeln('      ${field.name}: $deserializeExpr,');
    }

    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln();
  }

  void _writeToMapMethod(StringBuffer buffer, ParsedModel model) {
    buffer.writeln('  Map<String, dynamic> toMap() {');
    buffer.writeln('    return {');

    for (final field in model.fields) {
      final serializeExpr = _serializeToMapExpression(field.name, field.type);
      buffer.writeln("      '${field.name}': $serializeExpr,");
    }

    buffer.writeln('    };');
    buffer.writeln('  }');
  }

  /// Generates the deserialization expression for a field from a map.
  String _deserializeFromMapExpression(String valueExpr, ParsedType type) {
    if (type.isNullable) {
      return '$valueExpr == null ? null : '
          '${_deserializeFromMapExpression(valueExpr, type.asNonNullable)}';
    }

    if (type.isBasicType) {
      final baseType = type.baseName;
      if (baseType == 'String') {
        return '$valueExpr as String';
      } else if (baseType == 'int') {
        return '$valueExpr as int';
      } else if (baseType == 'double') {
        return '($valueExpr as num).toDouble()';
      } else if (baseType == 'bool') {
        return '$valueExpr as bool';
      } else if (baseType == 'num') {
        return '$valueExpr as num';
      } else if (baseType == 'DateTime') {
        return 'DateTime.parse($valueExpr as String)';
      }
    }

    if (type.isList) {
      final innerType = type.innerType;
      if (innerType == null) {
        return '$valueExpr as List<dynamic>';
      }
      final innerExpr = _deserializeFromMapExpression('e', innerType);
      return '($valueExpr as List).map((e) => $innerExpr).toList()';
    }

    if (type.isMap) {
      return 'Map<String, dynamic>.from($valueExpr as Map)';
    }

    if (type.isDynamic) {
      return valueExpr;
    }

    // Custom model type
    return '${type.baseName}.fromMap(Map<String, dynamic>.from($valueExpr as Map))';
  }

  /// Generates the serialization expression for a field to a map.
  String _serializeToMapExpression(String valueExpr, ParsedType type) {
    if (type.isNullable) {
      return '$valueExpr == null ? null : '
          '${_serializeToMapExpression(valueExpr, type.asNonNullable)}';
    }

    if (type.isBasicType) {
      if (type.baseName == 'DateTime') {
        return '$valueExpr.toIso8601String()';
      }
      return valueExpr;
    }

    if (type.isList) {
      final innerType = type.innerType;
      if (innerType == null) {
        return valueExpr;
      }
      // For Lists of basic types (except DateTime), return identity
      // DateTime and custom models need transformation
      if (innerType.isBasicType &&
          innerType.baseName != 'DateTime' &&
          !innerType.isNullable) {
        return valueExpr;
      }
      final innerExpr = _serializeToMapExpression('e', innerType);
      return '$valueExpr.map((e) => $innerExpr).toList()';
    }

    if (type.isMap || type.isDynamic) {
      return valueExpr;
    }

    // Custom model type
    return '$valueExpr.toMap()';
  }
}
