import 'package:fluttron_cli/src/generate/parsed_contract.dart';

/// Generator for Client-side service client code.
///
/// Takes a [ParsedServiceContract] and generates a Dart file with:
/// - A typed client class that wraps `FluttronClient`
/// - Typed method wrappers that call `invoke()` with correct parameters
/// - Result deserialization from JSON to Dart types
class ClientServiceGenerator {
  /// Creates a [ClientServiceGenerator] with optional configuration.
  const ClientServiceGenerator({
    this.generatedBy = 'fluttron generate services',
    this.sourceFile,
  });

  /// The tool name to include in the generated header.
  final String generatedBy;

  /// The source file path to include in the generated header.
  final String? sourceFile;

  /// Generates the Client-side Dart code for the given [contract].
  ///
  /// The generated code is a class named `{ClassName}Client`
  /// that wraps `FluttronClient` and provides typed method wrappers
  /// that invoke the corresponding Host service methods.
  String generate(ParsedServiceContract contract) {
    final buffer = StringBuffer();

    // Write header
    _writeHeader(buffer);

    // Write imports
    _writeImports(buffer);

    // Write class declaration
    _writeClassDeclaration(buffer, contract);

    // Write constructor
    _writeConstructor(buffer, contract);

    // Write methods
    _writeMethods(buffer, contract);

    // Close class
    buffer.writeln('}');

    return buffer.toString();
  }

  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// GENERATED CODE â€” DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by: $generatedBy');
    if (sourceFile != null) {
      buffer.writeln('// Source: $sourceFile');
    }
    buffer.writeln('// Timestamp: ${DateTime.now().toUtc().toIso8601String()}');
    buffer.writeln();
  }

  void _writeImports(StringBuffer buffer) {
    buffer.writeln("import 'package:fluttron_ui/fluttron_ui.dart';");
    buffer.writeln();
  }

  void _writeClassDeclaration(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    buffer.writeln(
      '/// Type-safe client for the ${contract.namespace} host service.',
    );
    buffer.writeln('class ${contract.className}Client {');
  }

  void _writeConstructor(StringBuffer buffer, ParsedServiceContract contract) {
    buffer.writeln(
      '  /// Creates a [${contract.className}Client] with the given [FluttronClient].',
    );
    buffer.writeln('  ${contract.className}Client(this._client);');
    buffer.writeln();
    buffer.writeln('  final FluttronClient _client;');
    buffer.writeln();
  }

  void _writeMethods(StringBuffer buffer, ParsedServiceContract contract) {
    for (final method in contract.methods) {
      _writeMethod(buffer, contract, method);
    }
  }

  void _writeMethod(
    StringBuffer buffer,
    ParsedServiceContract contract,
    ParsedMethod method,
  ) {
    // Write documentation if available
    if (method.documentation != null) {
      for (final line in method.documentation!.split('\n')) {
        buffer.writeln('  /// $line');
      }
    }

    // Write method signature
    buffer.write('  ${_generateMethodSignature(method)} async {\n');

    // Write invoke call
    _writeInvokeCall(buffer, contract, method);

    // Write return statement with deserialization
    _writeReturnStatement(buffer, method);

    buffer.writeln('  }');
    buffer.writeln();
  }

  String _generateMethodSignature(ParsedMethod method) {
    final buffer = StringBuffer();

    // Return type
    buffer.write('${method.returnType.displayName} ');

    // Method name
    buffer.write(method.name);

    // Parameters
    buffer.write('(');

    final positionalParams = method.parameters
        .where((p) => !p.isNamed)
        .toList();
    final namedParams = method.parameters.where((p) => p.isNamed).toList();

    // Positional parameters
    for (var i = 0; i < positionalParams.length; i++) {
      final param = positionalParams[i];
      buffer.write('${param.type.displayName} ${param.name}');
      if (i < positionalParams.length - 1 || namedParams.isNotEmpty) {
        buffer.write(', ');
      }
    }

    // Named parameters
    if (namedParams.isNotEmpty) {
      buffer.write('{');
      for (var i = 0; i < namedParams.length; i++) {
        final param = namedParams[i];
        buffer.write('${param.type.displayName} ${param.name}');
        if (param.hasDefaultValue) {
          buffer.write(' = ${param.defaultValue}');
        }
        if (i < namedParams.length - 1) {
          buffer.write(', ');
        }
      }
      buffer.write('}');
    }

    buffer.write(')');

    return buffer.toString();
  }

  void _writeInvokeCall(
    StringBuffer buffer,
    ParsedServiceContract contract,
    ParsedMethod method,
  ) {
    final hasParams = method.parameters.isNotEmpty;

    if (hasParams) {
      buffer.writeln('    final result = await _client.invoke(');
      buffer.writeln("      '${contract.namespace}.${method.name}',");
      _writeParamsMap(buffer, method);
      buffer.writeln('    );');
    } else {
      buffer.writeln(
        "    final result = await _client.invoke('${contract.namespace}.${method.name}', {});",
      );
    }
  }

  void _writeParamsMap(StringBuffer buffer, ParsedMethod method) {
    buffer.writeln('      {');

    for (final param in method.parameters) {
      // Only include non-null optional parameters in the params map
      if (param.isNamed && param.type.isNullable && !param.hasDefaultValue) {
        buffer.writeln(
          "        if (${param.name} != null) '${param.name}': ${param.name},",
        );
      } else {
        buffer.writeln("        '${param.name}': ${param.name},");
      }
    }

    buffer.writeln('      },');
  }

  void _writeReturnStatement(StringBuffer buffer, ParsedMethod method) {
    final returnType = method.returnType.innerType;

    // Handle void return
    if (returnType == null || returnType.isVoid) {
      // No return needed for void
      return;
    }

    // Handle nullable return type
    if (returnType.isNullable && returnType.isBasicType) {
      _writeNullableBasicTypeReturn(buffer, returnType);
      return;
    }

    // Handle basic return types
    if (returnType.isBasicType && !returnType.isList && !returnType.isMap) {
      _writeBasicTypeReturn(buffer, returnType);
      return;
    }

    // Handle List types
    if (returnType.isList) {
      _writeListReturn(buffer, returnType);
      return;
    }

    // Handle Map types
    if (returnType.isMap) {
      buffer.writeln('    return Map<String, dynamic>.from(result as Map);');
      return;
    }

    // Handle custom model types
    _writeModelReturn(buffer, returnType);
  }

  void _writeBasicTypeReturn(StringBuffer buffer, ParsedType returnType) {
    final baseName = returnType.baseName;

    if (baseName == 'DateTime') {
      buffer.writeln("    return DateTime.parse(result['result'] as String);");
    } else {
      buffer.writeln(
        "    return result['result'] as ${returnType.displayName};",
      );
    }
  }

  void _writeNullableBasicTypeReturn(
    StringBuffer buffer,
    ParsedType returnType,
  ) {
    final baseName = returnType.baseName;

    if (baseName == 'DateTime') {
      buffer.writeln("    final value = result['result'];");
      buffer.writeln("    if (value == null) return null;");
      buffer.writeln("    return DateTime.parse(value as String);");
    } else {
      buffer.writeln(
        "    return result['result'] as ${returnType.displayName};",
      );
    }
  }

  void _writeListReturn(StringBuffer buffer, ParsedType returnType) {
    final innerType = returnType.innerType;

    if (innerType == null) {
      buffer.writeln('    return result as ${returnType.displayName};');
      return;
    }

    // List of basic types
    if (innerType.isBasicType && !innerType.isList && !innerType.isMap) {
      if (innerType.baseName == 'DateTime') {
        buffer.writeln('    final list = result as List<dynamic>;');
        buffer.writeln(
          '    return list.map((e) => DateTime.parse(e as String)).toList();',
        );
      } else {
        buffer.writeln('    final list = result as List<dynamic>;');
        buffer.writeln('    return list.cast<${innerType.displayName}>();');
      }
      return;
    }

    // List of Map
    if (innerType.isMap) {
      buffer.writeln('    final list = result as List<dynamic>;');
      buffer.writeln(
        "    return list.map((e) => Map<String, dynamic>.from(e as Map)).toList();",
      );
      return;
    }

    // List of custom models
    buffer.writeln('    final list = result as List<dynamic>;');
    buffer.writeln('    return list');
    buffer.writeln(
      "        .map((e) => ${innerType.displayName}.fromMap(Map<String, dynamic>.from(e as Map)))",
    );
    buffer.writeln('        .toList();');
  }

  void _writeModelReturn(StringBuffer buffer, ParsedType returnType) {
    buffer.writeln(
      '    return ${returnType.displayName}.fromMap(Map<String, dynamic>.from(result as Map));',
    );
  }
}
