import 'package:fluttron_cli/src/generate/parsed_contract.dart';

/// Generator for Client-side service client code.
///
/// Takes a [ParsedServiceContract] and generates a Dart file with:
/// - A typed client class that wraps `FluttronClient`
/// - Typed method wrappers that call `invoke()` with correct parameters
/// - Result deserialization from JSON to Dart types
class ClientServiceGenerator {
  /// Creates a [ClientServiceGenerator] with optional configuration.
  const ClientServiceGenerator({
    this.generatedBy = 'fluttron generate services',
    this.sourceFile,
    this.additionalImports = const [],
  });

  /// The tool name to include in the generated header.
  final String generatedBy;

  /// The source file path to include in the generated header.
  final String? sourceFile;

  /// Additional import URIs required by generated code (for example models).
  final List<String> additionalImports;

  /// Generates the Client-side Dart code for the given [contract].
  ///
  /// The generated code is a class named `{ClassName}Client`
  /// that wraps `FluttronClient` and provides typed method wrappers
  /// that invoke the corresponding Host service methods.
  String generate(ParsedServiceContract contract) {
    final buffer = StringBuffer();

    // Write header
    _writeHeader(buffer);

    // Write imports
    _writeImports(buffer);

    // Write class declaration
    _writeClassDeclaration(buffer, contract);

    // Write constructor
    _writeConstructor(buffer, contract);

    // Write methods
    _writeMethods(buffer, contract);

    // Close class
    buffer.writeln('}');

    return buffer.toString();
  }

  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// GENERATED CODE â€” DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by: $generatedBy');
    if (sourceFile != null) {
      buffer.writeln('// Source: $sourceFile');
    }
    buffer.writeln('// Timestamp: ${DateTime.now().toUtc().toIso8601String()}');
    buffer.writeln();
  }

  void _writeImports(StringBuffer buffer) {
    const baseImports = <String>['package:fluttron_ui/fluttron_ui.dart'];

    final seen = <String>{};
    for (final importUri in <String>[...baseImports, ...additionalImports]) {
      if (!seen.add(importUri)) {
        continue;
      }
      buffer.writeln("import '$importUri';");
    }
    buffer.writeln();
  }

  void _writeClassDeclaration(
    StringBuffer buffer,
    ParsedServiceContract contract,
  ) {
    buffer.writeln(
      '/// Type-safe client for the ${contract.namespace} host service.',
    );
    buffer.writeln('class ${contract.className}Client {');
  }

  void _writeConstructor(StringBuffer buffer, ParsedServiceContract contract) {
    buffer.writeln(
      '  /// Creates a [${contract.className}Client] with the given [FluttronClient].',
    );
    buffer.writeln('  ${contract.className}Client(this._client);');
    buffer.writeln();
    buffer.writeln('  final FluttronClient _client;');
    buffer.writeln();
  }

  void _writeMethods(StringBuffer buffer, ParsedServiceContract contract) {
    for (final method in contract.methods) {
      _writeMethod(buffer, contract, method);
    }
  }

  void _writeMethod(
    StringBuffer buffer,
    ParsedServiceContract contract,
    ParsedMethod method,
  ) {
    // Write documentation if available
    if (method.documentation != null) {
      for (final line in method.documentation!.split('\n')) {
        buffer.writeln('  /// $line');
      }
    }

    // Write method signature
    buffer.write('  ${_generateMethodSignature(method)} async {\n');

    // Write invoke call
    _writeInvokeCall(buffer, contract, method);

    // Write return statement with deserialization
    _writeReturnStatement(buffer, method);

    buffer.writeln('  }');
    buffer.writeln();
  }

  String _generateMethodSignature(ParsedMethod method) {
    final buffer = StringBuffer();

    // Return type
    buffer.write('${method.returnType.displayName} ');

    // Method name
    buffer.write(method.name);

    // Parameters
    buffer.write('(');

    final requiredPositionalParams = method.parameters
        .where((p) => !p.isNamed && p.isRequired)
        .toList();
    final optionalPositionalParams = method.parameters
        .where((p) => !p.isNamed && !p.isRequired)
        .toList();
    final namedParams = method.parameters.where((p) => p.isNamed).toList();

    var needsSeparator = false;

    for (final param in requiredPositionalParams) {
      if (needsSeparator) {
        buffer.write(', ');
      }
      _writeParameterDeclaration(buffer, param);
      needsSeparator = true;
    }

    if (optionalPositionalParams.isNotEmpty) {
      if (needsSeparator) {
        buffer.write(', ');
      }
      buffer.write('[');
      for (var i = 0; i < optionalPositionalParams.length; i++) {
        _writeParameterDeclaration(buffer, optionalPositionalParams[i]);
        if (i < optionalPositionalParams.length - 1) {
          buffer.write(', ');
        }
      }
      buffer.write(']');
      needsSeparator = true;
    }

    if (namedParams.isNotEmpty) {
      if (needsSeparator) {
        buffer.write(', ');
      }
      buffer.write('{');
      for (var i = 0; i < namedParams.length; i++) {
        _writeParameterDeclaration(buffer, namedParams[i]);
        if (i < namedParams.length - 1) {
          buffer.write(', ');
        }
      }
      buffer.write('}');
    }

    buffer.write(')');

    return buffer.toString();
  }

  void _writeParameterDeclaration(
    StringBuffer buffer,
    ParsedParameter parameter,
  ) {
    if (parameter.isNamed &&
        parameter.isRequired &&
        !parameter.hasDefaultValue) {
      buffer.write('required ');
    }

    buffer.write('${parameter.type.displayName} ${parameter.name}');
    if (parameter.hasDefaultValue) {
      buffer.write(' = ${parameter.defaultValue}');
    }
  }

  void _writeInvokeCall(
    StringBuffer buffer,
    ParsedServiceContract contract,
    ParsedMethod method,
  ) {
    final hasParams = method.parameters.isNotEmpty;

    if (hasParams) {
      buffer.writeln('    final result = await _client.invoke(');
      buffer.writeln("      '${contract.namespace}.${method.name}',");
      _writeParamsMap(buffer, method);
      buffer.writeln('    );');
    } else {
      buffer.writeln(
        "    final result = await _client.invoke('${contract.namespace}.${method.name}', {});",
      );
    }
  }

  void _writeParamsMap(StringBuffer buffer, ParsedMethod method) {
    buffer.writeln('      {');

    for (final param in method.parameters) {
      final omitNullOptional =
          param.isNamed && param.type.isNullable && !param.hasDefaultValue;
      final serializedExpr = _serializeForTransportExpression(
        param.name,
        omitNullOptional ? param.type.asNonNullable : param.type,
      );

      // Only include non-null optional parameters in the params map
      if (omitNullOptional) {
        buffer.writeln(
          "        if (${param.name} != null) '${param.name}': $serializedExpr,",
        );
      } else {
        buffer.writeln("        '${param.name}': $serializedExpr,");
      }
    }

    buffer.writeln('      },');
  }

  void _writeReturnStatement(StringBuffer buffer, ParsedMethod method) {
    final returnType = method.returnType.innerType;

    if (returnType == null || returnType.isVoid) {
      return;
    }

    final sourceExpr =
        returnType.isBasicType && !returnType.isList && !returnType.isMap
        ? "result['result']"
        : 'result';
    final deserializeExpr = _deserializeFromTransportExpression(
      sourceExpr,
      returnType,
    );
    buffer.writeln('    return $deserializeExpr;');
  }

  String _serializeForTransportExpression(String valueExpr, ParsedType type) {
    if (type.isNullable) {
      return '$valueExpr == null ? null : '
          '${_serializeForTransportExpression(valueExpr, type.asNonNullable)}';
    }

    if (type.isBasicType) {
      if (type.baseName == 'DateTime') {
        return '$valueExpr.toIso8601String()';
      }
      return valueExpr;
    }

    if (type.isList) {
      final innerType = type.innerType;
      if (innerType == null) {
        return valueExpr;
      }
      final innerExpr = _serializeForTransportExpression('e', innerType);
      return '$valueExpr.map((e) => $innerExpr).toList()';
    }

    if (type.isMap || type.isDynamic) {
      if (type.isDynamic) {
        return valueExpr;
      }
      final valueType = type.typeArguments.length > 1
          ? type.typeArguments[1]
          : null;
      if (valueType == null || valueType.isDynamic) {
        return valueExpr;
      }
      final valueSerializeExpr = _serializeForTransportExpression(
        'v',
        valueType,
      );
      return '$valueExpr.map((k, v) => MapEntry(k, $valueSerializeExpr))';
    }

    return '$valueExpr.toMap()';
  }

  String _deserializeFromTransportExpression(
    String valueExpr,
    ParsedType type,
  ) {
    if (type.isNullable) {
      return '$valueExpr == null ? null : '
          '${_deserializeFromTransportExpression(valueExpr, type.asNonNullable)}';
    }

    if (type.isBasicType) {
      final baseType = type.baseName;
      if (baseType == 'String') {
        return '$valueExpr as String';
      } else if (baseType == 'int') {
        return '$valueExpr as int';
      } else if (baseType == 'double') {
        return '($valueExpr as num).toDouble()';
      } else if (baseType == 'bool') {
        return '$valueExpr as bool';
      } else if (baseType == 'num') {
        return '$valueExpr as num';
      } else if (baseType == 'DateTime') {
        return 'DateTime.parse($valueExpr as String)';
      }
    }

    if (type.isList) {
      final innerType = type.innerType;
      if (innerType == null) {
        return '$valueExpr as List<dynamic>';
      }
      final innerExpr = _deserializeFromTransportExpression('e', innerType);
      return '($valueExpr as List).map((e) => $innerExpr).toList()';
    }

    if (type.isMap) {
      final valueType = type.typeArguments.length > 1
          ? type.typeArguments[1]
          : null;
      final sourceMapExpr = 'Map<String, dynamic>.from($valueExpr as Map)';
      if (valueType == null || valueType.isDynamic) {
        return sourceMapExpr;
      }
      final valueDeserializeExpr = _deserializeFromTransportExpression(
        'v',
        valueType,
      );
      return '$sourceMapExpr.map((k, v) => MapEntry(k, $valueDeserializeExpr))';
    }

    if (type.isDynamic) {
      return valueExpr;
    }

    return '${type.baseName}.fromMap(Map<String, dynamic>.from($valueExpr as Map))';
  }
}
