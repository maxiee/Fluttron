import 'dart:io';

import 'package:path/path.dart' as p;
import 'package:test/test.dart';

import 'package:fluttron_cli/src/utils/registration_generator.dart';
import 'package:fluttron_cli/src/utils/web_package_manifest.dart';

void main() {
  late RegistrationGenerator generator;
  late Directory tempDir;

  setUp(() {
    generator = RegistrationGenerator();
    tempDir = Directory.systemTemp.createTempSync(
      'registration_generator_test_',
    );
  });

  tearDown(() {
    if (tempDir.existsSync()) {
      tempDir.deleteSync(recursive: true);
    }
  });

  group('RegistrationResult', () {
    test('creates result with all fields', () {
      const result = RegistrationResult(
        outputPath: '/path/to/output.dart',
        packageCount: 3,
        factoryCount: 5,
        hasGenerated: true,
      );

      expect(result.outputPath, equals('/path/to/output.dart'));
      expect(result.packageCount, equals(3));
      expect(result.factoryCount, equals(5));
      expect(result.hasGenerated, isTrue);
    });

    test('toString includes all fields', () {
      const result = RegistrationResult(
        outputPath: '/test/path.dart',
        packageCount: 2,
        factoryCount: 4,
        hasGenerated: true,
      );

      expect(result.toString(), contains('outputPath: /test/path.dart'));
      expect(result.toString(), contains('packageCount: 2'));
      expect(result.toString(), contains('factoryCount: 4'));
      expect(result.toString(), contains('hasGenerated: true'));
    });
  });

  group('generateSync', () {
    test('generates file with single package single factory', () {
      final packages = [
        WebPackageManifest(
          version: '1',
          viewFactories: [
            const ViewFactory(
              type: 'milkdown.editor',
              jsFactoryName: 'fluttronCreateMilkdownEditorView',
            ),
          ],
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'milkdown_editor',
          rootPath: '/path/to/milkdown_editor',
        ),
      ];

      final result = generator.generateSync(
        uiProjectDir: tempDir,
        packages: packages,
      );

      expect(result.packageCount, equals(1));
      expect(result.factoryCount, equals(1));
      expect(result.hasGenerated, isTrue);
      expect(
        result.outputPath,
        contains('lib/generated/web_package_registrations.dart'),
      );

      // Verify file exists
      final outputFile = File(result.outputPath);
      expect(outputFile.existsSync(), isTrue);

      // Verify content
      final content = outputFile.readAsStringSync();
      expect(content, contains('GENERATED BY fluttron build'));
      expect(content, contains('void registerFluttronWebPackages()'));
      expect(
        content,
        contains("import 'package:fluttron_ui/fluttron_ui.dart'"),
      );
      expect(content, contains('// milkdown_editor'));
      expect(content, contains("type: 'milkdown.editor'"));
      expect(
        content,
        contains("jsFactoryName: 'fluttronCreateMilkdownEditorView'"),
      );
    });

    test('generates file with single package multiple factories', () {
      final packages = [
        WebPackageManifest(
          version: '1',
          viewFactories: [
            const ViewFactory(
              type: 'chartjs.bar',
              jsFactoryName: 'fluttronCreateChartjsBarView',
            ),
            const ViewFactory(
              type: 'chartjs.line',
              jsFactoryName: 'fluttronCreateChartjsLineView',
            ),
          ],
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'chartjs_wrapper',
          rootPath: '/path/to/chartjs_wrapper',
        ),
      ];

      final result = generator.generateSync(
        uiProjectDir: tempDir,
        packages: packages,
      );

      expect(result.packageCount, equals(1));
      expect(result.factoryCount, equals(2));
      expect(result.hasGenerated, isTrue);

      final content = File(result.outputPath).readAsStringSync();
      expect(content, contains('// chartjs_wrapper'));
      expect(content, contains("type: 'chartjs.bar'"));
      expect(content, contains("type: 'chartjs.line'"));
    });

    test('generates file with multiple packages', () {
      final packages = [
        WebPackageManifest(
          version: '1',
          viewFactories: [
            const ViewFactory(
              type: 'milkdown.editor',
              jsFactoryName: 'fluttronCreateMilkdownEditorView',
            ),
          ],
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'milkdown_editor',
          rootPath: '/path/to/milkdown_editor',
        ),
        WebPackageManifest(
          version: '1',
          viewFactories: [
            const ViewFactory(
              type: 'chartjs.bar',
              jsFactoryName: 'fluttronCreateChartjsBarView',
            ),
          ],
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'chartjs_wrapper',
          rootPath: '/path/to/chartjs_wrapper',
        ),
      ];

      final result = generator.generateSync(
        uiProjectDir: tempDir,
        packages: packages,
      );

      expect(result.packageCount, equals(2));
      expect(result.factoryCount, equals(2));
      expect(result.hasGenerated, isTrue);

      final content = File(result.outputPath).readAsStringSync();
      expect(content, contains('// milkdown_editor'));
      expect(content, contains('// chartjs_wrapper'));
    });

    test(
      'keeps conflicting registrations for runtime strict conflict checks',
      () {
        final packages = [
          WebPackageManifest(
            version: '1',
            viewFactories: [
              const ViewFactory(
                type: 'chart.editor',
                jsFactoryName: 'fluttronCreateChartEditorV1View',
              ),
            ],
            assets: const Assets(js: ['web/ext/main.js']),
            packageName: 'chart_v1',
            rootPath: '/path/to/chart_v1',
          ),
          WebPackageManifest(
            version: '1',
            viewFactories: [
              const ViewFactory(
                type: 'chart.editor',
                jsFactoryName: 'fluttronCreateChartEditorV2View',
              ),
            ],
            assets: const Assets(js: ['web/ext/main.js']),
            packageName: 'chart_v2',
            rootPath: '/path/to/chart_v2',
          ),
        ];

        final result = generator.generateSync(
          uiProjectDir: tempDir,
          packages: packages,
        );

        expect(result.factoryCount, equals(2));
        final content = File(result.outputPath).readAsStringSync();
        expect(
          content,
          contains("jsFactoryName: 'fluttronCreateChartEditorV1View'"),
        );
        expect(
          content,
          contains("jsFactoryName: 'fluttronCreateChartEditorV2View'"),
        );

        final typeMatches = RegExp(
          r"type: 'chart\.editor'",
        ).allMatches(content);
        expect(typeMatches.length, equals(2));
      },
    );

    test('generates empty file when no packages', () {
      final result = generator.generateSync(
        uiProjectDir: tempDir,
        packages: [],
      );

      expect(result.packageCount, equals(0));
      expect(result.factoryCount, equals(0));
      expect(result.hasGenerated, isFalse);

      final content = File(result.outputPath).readAsStringSync();
      expect(content, contains('GENERATED BY fluttron build'));
      expect(content, contains('void registerFluttronWebPackages()'));
      expect(content, contains('// No web packages to register'));
    });

    test('generates empty file when packages have no factories', () {
      // This is an edge case that shouldn't happen in practice
      // because manifest validation requires at least one factory
      final packages = [
        WebPackageManifest(
          version: '1',
          viewFactories: [], // Empty factories
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'empty_package',
        ),
      ];

      final result = generator.generateSync(
        uiProjectDir: tempDir,
        packages: packages,
      );

      expect(result.factoryCount, equals(0));
      expect(result.hasGenerated, isFalse);
    });

    test('creates output directory if it does not exist', () {
      final packages = [
        WebPackageManifest(
          version: '1',
          viewFactories: [
            const ViewFactory(
              type: 'test.view',
              jsFactoryName: 'fluttronCreateTestView',
            ),
          ],
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'test_package',
        ),
      ];

      // Ensure generated directory doesn't exist
      final generatedDir = Directory(p.join(tempDir.path, 'lib', 'generated'));
      expect(generatedDir.existsSync(), isFalse);

      final result = generator.generateSync(
        uiProjectDir: tempDir,
        packages: packages,
      );

      // Directory should be created
      expect(generatedDir.existsSync(), isTrue);
      expect(File(result.outputPath).existsSync(), isTrue);
    });

    test('uses custom output directory', () {
      final packages = [
        WebPackageManifest(
          version: '1',
          viewFactories: [
            const ViewFactory(
              type: 'test.view',
              jsFactoryName: 'fluttronCreateTestView',
            ),
          ],
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'test_package',
        ),
      ];

      final result = generator.generateSync(
        uiProjectDir: tempDir,
        packages: packages,
        outputDir: 'lib/custom_gen',
      );

      expect(
        result.outputPath,
        contains('lib/custom_gen/web_package_registrations.dart'),
      );
      expect(File(result.outputPath).existsSync(), isTrue);
    });

    test('escapes special characters in type and factory name', () {
      final packages = [
        WebPackageManifest(
          version: '1',
          viewFactories: [
            const ViewFactory(
              type: "test.view's", // Contains single quote
              jsFactoryName:
                  "fluttronCreateTest'sView", // Contains single quote
            ),
          ],
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'test_package',
        ),
      ];

      final result = generator.generateSync(
        uiProjectDir: tempDir,
        packages: packages,
      );

      final content = File(result.outputPath).readAsStringSync();
      // Single quotes should be escaped
      expect(content, contains(r"type: 'test.view\'s'"));
      expect(content, contains(r"jsFactoryName: 'fluttronCreateTest\'sView'"));
    });

    test('generates valid Dart syntax', () {
      final packages = [
        WebPackageManifest(
          version: '1',
          viewFactories: [
            const ViewFactory(
              type: 'milkdown.editor',
              jsFactoryName: 'fluttronCreateMilkdownEditorView',
            ),
          ],
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'milkdown_editor',
        ),
      ];

      generator.generateSync(uiProjectDir: tempDir, packages: packages);

      final content = File(
        p.join(
          tempDir.path,
          'lib',
          'generated',
          'web_package_registrations.dart',
        ),
      ).readAsStringSync();

      // Check for proper structure
      expect(content, contains('const FluttronWebViewRegistration('));
      expect(content, contains('FluttronWebViewRegistry.register('));
      expect(content, contains('ignore_for_file: directives_ordering'));
    });
  });

  group('generate (async)', () {
    test('generates same content as sync version', () async {
      final packages = [
        WebPackageManifest(
          version: '1',
          viewFactories: [
            const ViewFactory(
              type: 'milkdown.editor',
              jsFactoryName: 'fluttronCreateMilkdownEditorView',
            ),
          ],
          assets: const Assets(js: ['web/ext/main.js']),
          packageName: 'milkdown_editor',
        ),
      ];

      // Create two temp directories
      final syncDir = Directory.systemTemp.createTempSync('sync_test_');
      final asyncDir = Directory.systemTemp.createTempSync('async_test_');

      try {
        // Generate sync
        final syncResult = generator.generateSync(
          uiProjectDir: syncDir,
          packages: packages,
        );

        // Generate async
        final asyncResult = await generator.generate(
          uiProjectDir: asyncDir,
          packages: packages,
        );

        // Compare results
        expect(asyncResult.packageCount, equals(syncResult.packageCount));
        expect(asyncResult.factoryCount, equals(syncResult.factoryCount));
        expect(asyncResult.hasGenerated, equals(syncResult.hasGenerated));

        // Compare file contents
        final syncContent = File(syncResult.outputPath).readAsStringSync();
        final asyncContent = File(asyncResult.outputPath).readAsStringSync();
        expect(asyncContent, equals(syncContent));
      } finally {
        syncDir.deleteSync(recursive: true);
        asyncDir.deleteSync(recursive: true);
      }
    });
  });

  group('RegistrationGenerator constants', () {
    test('defaultOutputDir is correct', () {
      expect(RegistrationGenerator.defaultOutputDir, equals('lib/generated'));
    });

    test('defaultOutputFilename is correct', () {
      expect(
        RegistrationGenerator.defaultOutputFilename,
        equals('web_package_registrations.dart'),
      );
    });
  });
}
