import 'package:test/test.dart';

import 'package:fluttron_cli/src/generate/model_generator.dart';
import 'package:fluttron_cli/src/generate/parsed_contract.dart';

void main() {
  late ModelGenerator generator;

  setUp(() {
    generator = const ModelGenerator(
      generatedBy: 'test',
      sourceFile: 'test_model.dart',
    );
  });

  group('ModelGenerator', () {
    group('header generation', () {
      test('includes generated by header', () {
        final model = ParsedModel(className: 'TestModel', fields: []);
        final code = generator.generate(model);
        expect(code, contains('// GENERATED CODE — DO NOT MODIFY BY HAND'));
        expect(code, contains('// Generated by: test'));
        expect(code, contains('// Source: test_model.dart'));
        expect(code, contains('// Timestamp:'));
      });
    });

    group('class declaration', () {
      test('generates class with correct name', () {
        final model = ParsedModel(className: 'WeatherInfo', fields: []);
        final code = generator.generate(model);
        expect(code, contains('class WeatherInfo {'));
      });

      test('includes class documentation', () {
        final model = ParsedModel(
          className: 'WeatherInfo',
          fields: [],
          documentation: 'Weather information model.',
        );
        final code = generator.generate(model);
        expect(code, contains('/// Weather information model.'));
      });

      test('includes multi-line class documentation', () {
        final model = ParsedModel(
          className: 'WeatherInfo',
          fields: [],
          documentation:
              'Weather information.\nContains temperature and conditions.',
        );
        final code = generator.generate(model);
        expect(code, contains('/// Weather information.'));
        expect(code, contains('/// Contains temperature and conditions.'));
      });
    });

    group('field generation', () {
      test('generates basic String field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'name',
              type: const ParsedType(displayName: 'String', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('final String name;'));
      });

      test('generates basic int field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'count',
              type: const ParsedType(displayName: 'int', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('final int count;'));
      });

      test('generates basic double field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'value',
              type: const ParsedType(displayName: 'double', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('final double value;'));
      });

      test('generates basic bool field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'flag',
              type: const ParsedType(displayName: 'bool', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('final bool flag;'));
      });

      test('generates DateTime field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'timestamp',
              type: const ParsedType(
                displayName: 'DateTime',
                isNullable: false,
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('final DateTime timestamp;'));
      });

      test('generates nullable field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'optionalName',
              type: const ParsedType(displayName: 'String?', isNullable: true),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('final String? optionalName;'));
      });

      test('generates List field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'items',
              type: const ParsedType(
                displayName: 'List<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('final List<String> items;'));
      });

      test('generates Map field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'data',
              type: const ParsedType(
                displayName: 'Map<String, dynamic>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                  ParsedType(displayName: 'dynamic', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('final Map<String, dynamic> data;'));
      });

      test('includes field documentation', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'name',
              type: const ParsedType(displayName: 'String', isNullable: false),
              documentation: 'The name of the entity.',
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('/// The name of the entity.'));
      });
    });

    group('constructor generation', () {
      test('generates const constructor with required fields', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'name',
              type: const ParsedType(displayName: 'String', isNullable: false),
            ),
            ParsedField(
              name: 'count',
              type: const ParsedType(displayName: 'int', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('const TestModel({'));
        expect(code, contains('required this.name,'));
        expect(code, contains('required this.count,'));
      });

      test('generates constructor with nullable field as optional', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'name',
              type: const ParsedType(displayName: 'String', isNullable: false),
            ),
            ParsedField(
              name: 'optionalValue',
              type: const ParsedType(displayName: 'String?', isNullable: true),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains('required this.name,'));
        expect(code, contains('this.optionalValue,'));
      });
    });

    group('fromMap generation', () {
      test('generates fromMap factory', () {
        final model = ParsedModel(className: 'TestModel', fields: []);
        final code = generator.generate(model);
        expect(
          code,
          contains('factory TestModel.fromMap(Map<String, dynamic> map) {'),
        );
        expect(code, contains('return TestModel('));
      });

      test('deserializes String field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'name',
              type: const ParsedType(displayName: 'String', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("name: map['name'] as String,"));
      });

      test('deserializes int field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'count',
              type: const ParsedType(displayName: 'int', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("count: map['count'] as int,"));
      });

      test('deserializes double field with toDouble()', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'value',
              type: const ParsedType(displayName: 'double', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("value: (map['value'] as num).toDouble(),"));
      });

      test('deserializes bool field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'flag',
              type: const ParsedType(displayName: 'bool', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("flag: map['flag'] as bool,"));
      });

      test('deserializes DateTime field with DateTime.parse', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'timestamp',
              type: const ParsedType(
                displayName: 'DateTime',
                isNullable: false,
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains("timestamp: DateTime.parse(map['timestamp'] as String),"),
        );
      });

      test('deserializes nullable field with null check', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'optionalName',
              type: const ParsedType(displayName: 'String?', isNullable: true),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "optionalName: map['optionalName'] == null ? null : map['optionalName'] as String,",
          ),
        );
      });

      test('deserializes nullable DateTime field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'optionalDate',
              type: const ParsedType(
                displayName: 'DateTime?',
                isNullable: true,
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "optionalDate: map['optionalDate'] == null ? null : DateTime.parse(map['optionalDate'] as String),",
          ),
        );
      });

      test('deserializes List<String> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'items',
              type: const ParsedType(
                displayName: 'List<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "items: (map['items'] as List).map((e) => e as String).toList(),",
          ),
        );
      });

      test('deserializes List<int> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'ids',
              type: const ParsedType(
                displayName: 'List<int>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'int', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains("ids: (map['ids'] as List).map((e) => e as int).toList(),"),
        );
      });

      test('deserializes List<DateTime> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'dates',
              type: const ParsedType(
                displayName: 'List<DateTime>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'DateTime', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "dates: (map['dates'] as List).map((e) => DateTime.parse(e as String)).toList(),",
          ),
        );
      });

      test('deserializes Map<String, dynamic> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'data',
              type: const ParsedType(
                displayName: 'Map<String, dynamic>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                  ParsedType(displayName: 'dynamic', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains("data: Map<String, dynamic>.from(map['data'] as Map),"),
        );
      });

      test('deserializes Map<String, int> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'counts',
              type: const ParsedType(
                displayName: 'Map<String, int>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                  ParsedType(displayName: 'int', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "counts: Map<String, dynamic>.from(map['counts'] as Map).map((k, v) => MapEntry(k, v as int)),",
          ),
        );
      });

      test('deserializes custom model field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'user',
              type: const ParsedType(displayName: 'User', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "user: User.fromMap(Map<String, dynamic>.from(map['user'] as Map)),",
          ),
        );
      });

      test('deserializes List of custom models', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'users',
              type: const ParsedType(
                displayName: 'List<User>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'User', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "users: (map['users'] as List).map((e) => User.fromMap(Map<String, dynamic>.from(e as Map))).toList(),",
          ),
        );
      });
    });

    group('toMap generation', () {
      test('generates toMap method', () {
        final model = ParsedModel(className: 'TestModel', fields: []);
        final code = generator.generate(model);
        expect(code, contains('Map<String, dynamic> toMap() {'));
        expect(code, contains('return {'));
      });

      test('serializes String field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'name',
              type: const ParsedType(displayName: 'String', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("'name': name,"));
      });

      test('serializes int field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'count',
              type: const ParsedType(displayName: 'int', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("'count': count,"));
      });

      test('serializes double field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'value',
              type: const ParsedType(displayName: 'double', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("'value': value,"));
      });

      test('serializes bool field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'flag',
              type: const ParsedType(displayName: 'bool', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("'flag': flag,"));
      });

      test('serializes DateTime field with toIso8601String', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'timestamp',
              type: const ParsedType(
                displayName: 'DateTime',
                isNullable: false,
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("'timestamp': timestamp.toIso8601String(),"));
      });

      test('serializes nullable field with null check', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'optionalName',
              type: const ParsedType(displayName: 'String?', isNullable: true),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "'optionalName': optionalName == null ? null : optionalName,",
          ),
        );
      });

      test('serializes nullable DateTime field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'optionalDate',
              type: const ParsedType(
                displayName: 'DateTime?',
                isNullable: true,
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "'optionalDate': optionalDate == null ? null : optionalDate.toIso8601String(),",
          ),
        );
      });

      test('serializes List<String> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'items',
              type: const ParsedType(
                displayName: 'List<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("'items': items,"));
      });

      test('serializes List<DateTime> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'dates',
              type: const ParsedType(
                displayName: 'List<DateTime>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'DateTime', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains("'dates': dates.map((e) => e.toIso8601String()).toList(),"),
        );
      });

      test('serializes Map<String, dynamic> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'data',
              type: const ParsedType(
                displayName: 'Map<String, dynamic>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                  ParsedType(displayName: 'dynamic', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("'data': data,"));
      });

      test('serializes Map<String, DateTime> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'timestamps',
              type: const ParsedType(
                displayName: 'Map<String, DateTime>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                  ParsedType(displayName: 'DateTime', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains(
            "'timestamps': timestamps.map((k, v) => MapEntry(k, v.toIso8601String())),",
          ),
        );
      });

      test('serializes custom model field with toMap', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'user',
              type: const ParsedType(displayName: 'User', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(code, contains("'user': user.toMap(),"));
      });

      test('serializes List of custom models', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'users',
              type: const ParsedType(
                displayName: 'List<User>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'User', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);
        expect(
          code,
          contains("'users': users.map((e) => e.toMap()).toList(),"),
        );
      });
    });

    group('full model generation', () {
      test('generates complete model for WeatherInfo', () {
        final model = ParsedModel(
          className: 'WeatherInfo',
          fields: [
            ParsedField(
              name: 'city',
              type: const ParsedType(displayName: 'String', isNullable: false),
            ),
            ParsedField(
              name: 'temperature',
              type: const ParsedType(displayName: 'double', isNullable: false),
            ),
            ParsedField(
              name: 'condition',
              type: const ParsedType(displayName: 'String', isNullable: false),
            ),
            ParsedField(
              name: 'timestamp',
              type: const ParsedType(
                displayName: 'DateTime',
                isNullable: false,
              ),
            ),
          ],
        );

        final code = generator.generate(model);

        // Verify header
        expect(code, contains('// GENERATED CODE — DO NOT MODIFY BY HAND'));
        expect(code, contains('// Generated by: test'));

        // Verify class declaration
        expect(code, contains('class WeatherInfo {'));

        // Verify fields
        expect(code, contains('final String city;'));
        expect(code, contains('final double temperature;'));
        expect(code, contains('final String condition;'));
        expect(code, contains('final DateTime timestamp;'));

        // Verify constructor
        expect(code, contains('const WeatherInfo({'));
        expect(code, contains('required this.city,'));
        expect(code, contains('required this.temperature,'));
        expect(code, contains('required this.condition,'));
        expect(code, contains('required this.timestamp,'));

        // Verify fromMap
        expect(
          code,
          contains('factory WeatherInfo.fromMap(Map<String, dynamic> map) {'),
        );
        expect(code, contains("city: map['city'] as String,"));
        expect(
          code,
          contains("temperature: (map['temperature'] as num).toDouble(),"),
        );
        expect(code, contains("condition: map['condition'] as String,"));
        expect(
          code,
          contains("timestamp: DateTime.parse(map['timestamp'] as String),"),
        );

        // Verify toMap
        expect(code, contains('Map<String, dynamic> toMap() {'));
        expect(code, contains("'city': city,"));
        expect(code, contains("'temperature': temperature,"));
        expect(code, contains("'condition': condition,"));
        expect(code, contains("'timestamp': timestamp.toIso8601String(),"));
      });

      test('generates complete model with complex types', () {
        final model = ParsedModel(
          className: 'TestModel',
          documentation: 'A complex model with various field types.',
          fields: [
            ParsedField(
              name: 'name',
              type: const ParsedType(displayName: 'String', isNullable: false),
              documentation: 'The name.',
            ),
            ParsedField(
              name: 'count',
              type: const ParsedType(displayName: 'int', isNullable: false),
            ),
            ParsedField(
              name: 'value',
              type: const ParsedType(displayName: 'double', isNullable: false),
            ),
            ParsedField(
              name: 'flag',
              type: const ParsedType(displayName: 'bool', isNullable: false),
            ),
            ParsedField(
              name: 'timestamp',
              type: const ParsedType(
                displayName: 'DateTime',
                isNullable: false,
              ),
            ),
            ParsedField(
              name: 'nullableField',
              type: const ParsedType(displayName: 'String?', isNullable: true),
            ),
            ParsedField(
              name: 'listField',
              type: const ParsedType(
                displayName: 'List<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
            ParsedField(
              name: 'mapField',
              type: const ParsedType(
                displayName: 'Map<String, dynamic>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                  ParsedType(displayName: 'dynamic', isNullable: false),
                ],
              ),
            ),
          ],
        );

        final code = generator.generate(model);

        // Verify class documentation
        expect(code, contains('/// A complex model with various field types.'));

        // Verify field documentation
        expect(code, contains('/// The name.'));

        // Verify all field types
        expect(code, contains('final String name;'));
        expect(code, contains('final int count;'));
        expect(code, contains('final double value;'));
        expect(code, contains('final bool flag;'));
        expect(code, contains('final DateTime timestamp;'));
        expect(code, contains('final String? nullableField;'));
        expect(code, contains('final List<String> listField;'));
        expect(code, contains('final Map<String, dynamic> mapField;'));

        // Verify fromMap has all fields
        expect(code, contains("name: map['name'] as String,"));
        expect(code, contains("count: map['count'] as int,"));
        expect(code, contains("value: (map['value'] as num).toDouble(),"));
        expect(code, contains("flag: map['flag'] as bool,"));
        expect(
          code,
          contains("timestamp: DateTime.parse(map['timestamp'] as String),"),
        );
        expect(
          code,
          contains(
            "nullableField: map['nullableField'] == null ? null : map['nullableField'] as String,",
          ),
        );
        expect(
          code,
          contains(
            "listField: (map['listField'] as List).map((e) => e as String).toList(),",
          ),
        );
        expect(
          code,
          contains(
            "mapField: Map<String, dynamic>.from(map['mapField'] as Map),",
          ),
        );

        // Verify toMap has all fields
        expect(code, contains("'name': name,"));
        expect(code, contains("'count': count,"));
        expect(code, contains("'value': value,"));
        expect(code, contains("'flag': flag,"));
        expect(code, contains("'timestamp': timestamp.toIso8601String(),"));
        expect(
          code,
          contains(
            "'nullableField': nullableField == null ? null : nullableField,",
          ),
        );
        expect(code, contains("'listField': listField,"));
        expect(code, contains("'mapField': mapField,"));
      });
    });

    group('edge cases', () {
      test('handles model with no fields', () {
        final model = ParsedModel(className: 'EmptyModel', fields: []);
        final code = generator.generate(model);

        expect(code, contains('class EmptyModel {'));
        expect(code, contains('const EmptyModel({'));
        expect(
          code,
          contains('factory EmptyModel.fromMap(Map<String, dynamic> map) {'),
        );
        expect(code, contains('return EmptyModel('));
        expect(code, contains('Map<String, dynamic> toMap() {'));
      });

      test('handles nested List types', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'nestedList',
              type: const ParsedType(
                displayName: 'List<List<String>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<String>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);

        // fromMap should have nested map expressions
        expect(
          code,
          contains(
            "(map['nestedList'] as List).map((e) => (e as List).map((e) => e as String).toList()).toList(),",
          ),
        );

        // toMap: outer List needs identity map, inner List<String> is identity
        expect(
          code,
          contains("'nestedList': nestedList.map((e) => e).toList(),"),
        );
      });

      test('handles List<double> field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'values',
              type: const ParsedType(
                displayName: 'List<double>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'double', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);

        expect(
          code,
          contains(
            "values: (map['values'] as List).map((e) => (e as num).toDouble()).toList(),",
          ),
        );
      });

      test('handles nullable List field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'optionalItems',
              type: const ParsedType(
                displayName: 'List<String>?',
                isNullable: true,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(model);

        expect(
          code,
          contains(
            "optionalItems: map['optionalItems'] == null ? null : (map['optionalItems'] as List).map((e) => e as String).toList(),",
          ),
        );
        // toMap: List<String> is identity, so no .map needed
        expect(
          code,
          contains(
            "'optionalItems': optionalItems == null ? null : optionalItems,",
          ),
        );
      });

      test('handles nullable custom model field', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'optionalUser',
              type: const ParsedType(displayName: 'User?', isNullable: true),
            ),
          ],
        );
        final code = generator.generate(model);

        expect(
          code,
          contains(
            "optionalUser: map['optionalUser'] == null ? null : User.fromMap(Map<String, dynamic>.from(map['optionalUser'] as Map)),",
          ),
        );
        expect(
          code,
          contains(
            "'optionalUser': optionalUser == null ? null : optionalUser.toMap(),",
          ),
        );
      });

      test('handles num type', () {
        final model = ParsedModel(
          className: 'TestModel',
          fields: [
            ParsedField(
              name: 'number',
              type: const ParsedType(displayName: 'num', isNullable: false),
            ),
          ],
        );
        final code = generator.generate(model);

        expect(code, contains("number: map['number'] as num,"));
        expect(code, contains("'number': number,"));
      });
    });
  });
}
