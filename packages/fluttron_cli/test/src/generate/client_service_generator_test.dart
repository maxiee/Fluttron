import 'package:test/test.dart';

import 'package:fluttron_cli/src/generate/client_service_generator.dart';
import 'package:fluttron_cli/src/generate/parsed_contract.dart';

void main() {
  late ClientServiceGenerator generator;

  setUp(() {
    generator = const ClientServiceGenerator(
      generatedBy: 'test',
      sourceFile: 'test_contract.dart',
    );
  });

  group('ClientServiceGenerator', () {
    group('header generation', () {
      test('includes generated by header', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [],
        );
        final code = generator.generate(contract);
        expect(code, contains('// GENERATED CODE — DO NOT MODIFY BY HAND'));
        expect(code, contains('// Generated by: test'));
        expect(code, contains('// Source: test_contract.dart'));
        expect(code, contains('// Timestamp:'));
      });
    });

    group('imports generation', () {
      test('includes required imports', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [],
        );
        final code = generator.generate(contract);
        expect(code, contains("import 'package:fluttron_ui/fluttron_ui.dart'"));
      });

      test('includes additional model imports', () {
        final generatorWithModels = const ClientServiceGenerator(
          generatedBy: 'test',
          sourceFile: 'test_contract.dart',
          additionalImports: [
            'package:weather_service_shared/src/weather_info_generated.dart',
            'package:weather_service_shared/src/weather_forecast_generated.dart',
          ],
        );
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [],
        );
        final code = generatorWithModels.generate(contract);
        expect(
          code,
          contains(
            "import 'package:weather_service_shared/src/weather_info_generated.dart';",
          ),
        );
        expect(
          code,
          contains(
            "import 'package:weather_service_shared/src/weather_forecast_generated.dart';",
          ),
        );
      });
    });

    group('class declaration', () {
      test('generates client class with correct naming', () {
        final contract = ParsedServiceContract(
          className: 'WeatherService',
          namespace: 'weather',
          methods: [],
        );
        final code = generator.generate(contract);
        expect(code, contains('class WeatherServiceClient {'));
        expect(
          code,
          contains('/// Type-safe client for the weather host service.'),
        );
      });

      test('generates constructor and _client field', () {
        final contract = ParsedServiceContract(
          className: 'WeatherService',
          namespace: 'weather',
          methods: [],
        );
        final code = generator.generate(contract);
        expect(code, contains('WeatherServiceClient(this._client);'));
        expect(code, contains('final FluttronClient _client;'));
      });
    });

    group('method generation', () {
      test('generates method with no parameters', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'ping',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<bool>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'bool', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('Future<bool> ping() async {'));
        expect(code, contains("await _client.invoke('test.ping', {})"));
      });

      test('generates method with single positional parameter', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'greet',
              parameters: [
                ParsedParameter(
                  name: 'name',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('Future<String> greet(String name) async {'));
        expect(code, contains("'name': name"));
      });

      test('generates method with named parameter with default value', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'greet',
              parameters: [
                ParsedParameter(
                  name: 'name',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: false,
                  isNamed: true,
                  defaultValue: "'World'",
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains("Future<String> greet({String name = 'World'}) async {"),
        );
      });

      test('generates method with nullable named parameter', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'search',
              parameters: [
                ParsedParameter(
                  name: 'query',
                  type: const ParsedType(
                    displayName: 'String?',
                    isNullable: true,
                  ),
                  isRequired: false,
                  isNamed: true,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains('Future<String> search({String? query}) async {'),
        );
        expect(code, contains("if (query != null) 'query': query,"));
      });

      test('generates method with multiple positional parameters', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'add',
              parameters: [
                ParsedParameter(
                  name: 'a',
                  type: const ParsedType(displayName: 'int', isNullable: false),
                  isRequired: true,
                  isNamed: false,
                ),
                ParsedParameter(
                  name: 'b',
                  type: const ParsedType(displayName: 'int', isNullable: false),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<int>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'int', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('Future<int> add(int a, int b) async {'));
        expect(code, contains("'a': a,"));
        expect(code, contains("'b': b,"));
      });

      test('serializes map parameter values for transport', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'saveSchedule',
              parameters: [
                ParsedParameter(
                  name: 'schedule',
                  type: const ParsedType(
                    displayName: 'Map<String, DateTime>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                      ParsedType(displayName: 'DateTime', isNullable: false),
                    ],
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<void>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'void', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            "'schedule': schedule.map((k, v) => MapEntry(k, v.toIso8601String())),",
          ),
        );
      });
    });

    group('return deserialization', () {
      test('deserializes basic bool return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'isAvailable',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<bool>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'bool', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains("return result['result'] as bool;"));
      });

      test('deserializes basic String return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getMessage',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains("return result['result'] as String;"));
      });

      test('deserializes basic int return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getCount',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<int>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'int', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains("return result['result'] as int;"));
      });

      test('deserializes basic double return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getValue',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<double>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'double', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains("return (result['result'] as num).toDouble();"));
      });

      test('deserializes DateTime return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getTimestamp',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<DateTime>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'DateTime', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains("return DateTime.parse(result['result'] as String);"),
        );
      });

      test('deserializes custom model return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getUser',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<User>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'User', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            'return User.fromMap(Map<String, dynamic>.from(result as Map));',
          ),
        );
      });

      test('deserializes List of basic types', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getNames',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<List<String>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<String>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains('return (result as List).map((e) => e as String).toList();'),
        );
      });

      test('deserializes List of custom models', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getUsers',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<List<User>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<User>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'User', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            'return (result as List).map((e) => User.fromMap(Map<String, dynamic>.from(e as Map))).toList();',
          ),
        );
      });

      test('deserializes Map return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getConfig',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<Map<String, dynamic>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'Map<String, dynamic>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                      ParsedType(displayName: 'dynamic', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains('return Map<String, dynamic>.from(result as Map);'),
        );
      });

      test('deserializes Map<String, int> return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getCounts',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<Map<String, int>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'Map<String, int>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                      ParsedType(displayName: 'int', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            'return Map<String, dynamic>.from(result as Map).map((k, v) => MapEntry(k, v as int));',
          ),
        );
      });

      test('handles void return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'doSomething',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<void>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'void', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('Future<void> doSomething() async {'));
        // Should not have a return statement for void
        expect(code, isNot(contains('return result')));
      });
    });

    group('documentation', () {
      test('includes method documentation in generated code', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'ping',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<bool>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'bool', isNullable: false),
                ],
              ),
              documentation: 'Checks if the service is available.',
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('/// Checks if the service is available.'));
      });

      test('includes multi-line documentation', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'ping',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<bool>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'bool', isNullable: false),
                ],
              ),
              documentation:
                  'Checks if the service is available.\nReturns true if available.',
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('/// Checks if the service is available.'));
        expect(code, contains('/// Returns true if available.'));
      });
    });

    group('full code generation', () {
      test('generates complete client for complex contract', () {
        final contract = ParsedServiceContract(
          className: 'WeatherService',
          namespace: 'weather',
          methods: [
            ParsedMethod(
              name: 'getCurrentWeather',
              parameters: [
                ParsedParameter(
                  name: 'city',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<WeatherInfo>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'WeatherInfo', isNullable: false),
                ],
              ),
              documentation: 'Gets current weather for the given city.',
            ),
            ParsedMethod(
              name: 'getForecast',
              parameters: [
                ParsedParameter(
                  name: 'city',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
                ParsedParameter(
                  name: 'days',
                  type: const ParsedType(displayName: 'int', isNullable: false),
                  isRequired: false,
                  isNamed: true,
                  defaultValue: '5',
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<List<WeatherForecast>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<WeatherForecast>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(
                        displayName: 'WeatherForecast',
                        isNullable: false,
                      ),
                    ],
                  ),
                ],
              ),
              documentation: 'Gets the 5-day forecast.',
            ),
            ParsedMethod(
              name: 'isAvailable',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<bool>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'bool', isNullable: false),
                ],
              ),
              documentation: 'Checks if the weather API is available.',
            ),
          ],
        );

        final code = generator.generate(contract);

        // Verify header
        expect(code, contains('// GENERATED CODE — DO NOT MODIFY BY HAND'));
        expect(code, contains('// Generated by: test'));

        // Verify imports
        expect(code, contains("import 'package:fluttron_ui/fluttron_ui.dart'"));

        // Verify class declaration
        expect(code, contains('class WeatherServiceClient {'));
        expect(
          code,
          contains('/// Type-safe client for the weather host service.'),
        );

        // Verify constructor
        expect(code, contains('WeatherServiceClient(this._client);'));
        expect(code, contains('final FluttronClient _client;'));

        // Verify methods
        expect(
          code,
          contains(
            'Future<WeatherInfo> getCurrentWeather(String city) async {',
          ),
        );
        expect(
          code,
          contains(
            "Future<List<WeatherForecast>> getForecast(String city, {int days = 5}) async {",
          ),
        );
        expect(code, contains('Future<bool> isAvailable() async {'));

        // Verify invoke calls
        expect(code, contains("'weather.getCurrentWeather'"));
        expect(code, contains("'weather.getForecast'"));
        expect(code, contains("'weather.isAvailable'"));

        // Verify parameter map construction
        expect(code, contains("'city': city,"));
        expect(code, contains("'days': days,"));

        // Verify return deserialization
        expect(
          code,
          contains(
            'return WeatherInfo.fromMap(Map<String, dynamic>.from(result as Map));',
          ),
        );
        expect(
          code,
          contains(
            '.map((e) => WeatherForecast.fromMap(Map<String, dynamic>.from(e as Map)))',
          ),
        );
        expect(code, contains("return result['result'] as bool;"));

        // Verify documentation
        expect(code, contains('/// Gets current weather for the given city.'));
        expect(code, contains('/// Gets the 5-day forecast.'));
        expect(code, contains('/// Checks if the weather API is available.'));
      });
    });

    group('edge cases', () {
      test('handles nullable String return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'findName',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<String?>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String?', isNullable: true),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            "return result['result'] == null ? null : result['result'] as String;",
          ),
        );
      });

      test('handles nullable DateTime return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getOptionalDate',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<DateTime?>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'DateTime?', isNullable: true),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            "return result['result'] == null ? null : DateTime.parse(result['result'] as String);",
          ),
        );
      });

      test('handles List<int> return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getIds',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<List<int>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<int>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'int', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains('return (result as List).map((e) => e as int).toList();'),
        );
      });

      test('handles List<DateTime> return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getDates',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<List<DateTime>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<DateTime>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'DateTime', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            'return (result as List).map((e) => DateTime.parse(e as String)).toList();',
          ),
        );
      });

      test('handles List<Map<String, dynamic>> return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getDataList',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<List<Map<String, dynamic>>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<Map<String, dynamic>>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(
                        displayName: 'Map<String, dynamic>',
                        isNullable: false,
                        typeArguments: [
                          ParsedType(displayName: 'String', isNullable: false),
                          ParsedType(displayName: 'dynamic', isNullable: false),
                        ],
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            "return (result as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();",
          ),
        );
      });
    });
  });
}
