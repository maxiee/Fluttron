import 'package:test/test.dart';

import 'package:fluttron_cli/src/generate/host_service_generator.dart';
import 'package:fluttron_cli/src/generate/parsed_contract.dart';

void main() {
  late HostServiceGenerator generator;

  setUp(() {
    generator = const HostServiceGenerator(
      generatedBy: 'test',
      sourceFile: 'test_contract.dart',
    );
  });

  group('HostServiceGenerator', () {
    group('header generation', () {
      test('includes generated by header', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [],
        );
        final code = generator.generate(contract);
        expect(code, contains('// GENERATED CODE â€” DO NOT MODIFY BY HAND'));
        expect(code, contains('// Generated by: test'));
        expect(code, contains('// Source: test_contract.dart'));
        expect(code, contains('// Timestamp:'));
      });
    });

    group('imports generation', () {
      test('includes required imports', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains("import 'package:fluttron_host/fluttron_host.dart'"),
        );
        expect(
          code,
          contains("import 'package:fluttron_shared/fluttron_shared.dart'"),
        );
      });

      test('includes additional model imports', () {
        final generatorWithModels = const HostServiceGenerator(
          generatedBy: 'test',
          sourceFile: 'test_contract.dart',
          additionalImports: [
            'package:weather_service_shared/src/weather_info_generated.dart',
            'package:weather_service_shared/src/weather_forecast_generated.dart',
          ],
        );
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [],
        );
        final code = generatorWithModels.generate(contract);
        expect(
          code,
          contains(
            "import 'package:weather_service_shared/src/weather_info_generated.dart';",
          ),
        );
        expect(
          code,
          contains(
            "import 'package:weather_service_shared/src/weather_forecast_generated.dart';",
          ),
        );
      });
    });

    group('class declaration', () {
      test('generates abstract Base class extending FluttronService', () {
        final contract = ParsedServiceContract(
          className: 'WeatherService',
          namespace: 'weather',
          methods: [],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains('abstract class WeatherServiceBase extends FluttronService'),
        );
        expect(code, contains('/// Base class with routing logic.'));
        expect(
          code,
          contains('/// Extend this class to provide method implementations.'),
        );
      });

      test('generates namespace getter', () {
        final contract = ParsedServiceContract(
          className: 'WeatherService',
          namespace: 'weather',
          methods: [],
        );
        final code = generator.generate(contract);
        expect(code, contains('@override'));
        expect(code, contains("String get namespace => 'weather';"));
      });
    });

    group('handle method generation', () {
      test('generates handle method with switch/case structure', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            'Future<dynamic> handle(String method, Map<String, dynamic> params) async',
          ),
        );
        expect(code, contains('switch (method)'));
        expect(code, contains("'METHOD_NOT_FOUND'"));
      });

      test('generates case for each method', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'ping',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<bool>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'bool', isNullable: false),
                ],
              ),
            ),
            ParsedMethod(
              name: 'echo',
              parameters: [
                ParsedParameter(
                  name: 'text',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains("case 'ping'"));
        expect(code, contains("case 'echo'"));
      });
    });

    group('parameter extraction', () {
      test('generates _requireString for required String param', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'greet',
              parameters: [
                ParsedParameter(
                  name: 'name',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains("final name = _requireString(params, 'name');"));
        expect(
          code,
          contains(
            'String _requireString(Map<String, dynamic> params, String key)',
          ),
        );
      });

      test('generates _requireInt for required int param', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'count',
              parameters: [
                ParsedParameter(
                  name: 'amount',
                  type: const ParsedType(displayName: 'int', isNullable: false),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<int>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'int', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains("final amount = _requireInt(params, 'amount');"));
        expect(
          code,
          contains('int _requireInt(Map<String, dynamic> params, String key)'),
        );
      });

      test('generates _requireDouble for required double param', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'calculate',
              parameters: [
                ParsedParameter(
                  name: 'value',
                  type: const ParsedType(
                    displayName: 'double',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<double>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'double', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains("final value = _requireDouble(params, 'value');"),
        );
        expect(
          code,
          contains(
            'double _requireDouble(Map<String, dynamic> params, String key)',
          ),
        );
      });

      test('generates _requireBool for required bool param', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'setFlag',
              parameters: [
                ParsedParameter(
                  name: 'enabled',
                  type: const ParsedType(
                    displayName: 'bool',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<void>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'void', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains("final enabled = _requireBool(params, 'enabled');"),
        );
        expect(
          code,
          contains(
            'bool _requireBool(Map<String, dynamic> params, String key)',
          ),
        );
      });

      test('generates optional param with default value', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'greet',
              parameters: [
                ParsedParameter(
                  name: 'name',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: false,
                  isNamed: true,
                  defaultValue: "'World'",
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            "final name = params['name'] == null ? 'World' : params['name'] as String;",
          ),
        );
      });

      test('generates nullable optional param extraction', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'search',
              parameters: [
                ParsedParameter(
                  name: 'query',
                  type: const ParsedType(
                    displayName: 'String?',
                    isNullable: true,
                  ),
                  isRequired: false,
                  isNamed: true,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            "final query = params['query'] == null ? null : params['query'] as String;",
          ),
        );
      });

      test('generates _requireList for required List param', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'processIds',
              parameters: [
                ParsedParameter(
                  name: 'ids',
                  type: const ParsedType(
                    displayName: 'List<int>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'int', isNullable: false),
                    ],
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<void>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'void', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            "final ids = (_requireList(params, 'ids') as List).map((e) => e as int).toList();",
          ),
        );
        expect(
          code,
          contains(
            'List<dynamic> _requireList(Map<String, dynamic> params, String key)',
          ),
        );
      });

      test('generates _requireMap for required Map param', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'processData',
              parameters: [
                ParsedParameter(
                  name: 'data',
                  type: const ParsedType(
                    displayName: 'Map<String, dynamic>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                      ParsedType(displayName: 'dynamic', isNullable: false),
                    ],
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<void>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'void', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            "final data = Map<String, dynamic>.from(_requireMap(params, 'data') as Map);",
          ),
        );
        expect(
          code,
          contains(
            'Map<String, dynamic> _requireMap(Map<String, dynamic> params, String key)',
          ),
        );
      });

      test('deserializes required Map<String, int> param', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'processCounts',
              parameters: [
                ParsedParameter(
                  name: 'counts',
                  type: const ParsedType(
                    displayName: 'Map<String, int>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                      ParsedType(displayName: 'int', isNullable: false),
                    ],
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<void>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'void', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            "final counts = Map<String, dynamic>.from(_requireMap(params, 'counts') as Map).map((k, v) => MapEntry(k, v as int));",
          ),
        );
      });

      test('generates _requireDateTime for required DateTime param', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'setDate',
              parameters: [
                ParsedParameter(
                  name: 'timestamp',
                  type: const ParsedType(
                    displayName: 'DateTime',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<void>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'void', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains("final timestamp = _requireDateTime(params, 'timestamp');"),
        );
        expect(
          code,
          contains(
            'DateTime _requireDateTime(Map<String, dynamic> params, String key)',
          ),
        );
      });
    });

    group('return serialization', () {
      test('returns empty map for void return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'doSomething',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<void>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'void', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('return {};'));
      });

      test('wraps basic return type in result map', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getCount',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<int>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'int', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains("return {'result': result};"));
      });

      test('returns model.toMap() for custom model type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getUser',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<User>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'User', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('return result.toMap();'));
      });

      test('maps List of models to toMap()', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getUsers',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<List<User>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<User>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'User', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('return result.map((e) => e.toMap()).toList();'));
      });

      test('returns List directly for basic type lists', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getNames',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<List<String>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<String>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('return result;'));
      });

      test('returns Map directly for Map return type', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getConfig',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<Map<String, dynamic>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'Map<String, dynamic>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                      ParsedType(displayName: 'dynamic', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('return result;'));
      });

      test('serializes Map<String, DateTime> return type values', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'getSchedule',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<Map<String, DateTime>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'Map<String, DateTime>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(displayName: 'String', isNullable: false),
                      ParsedType(displayName: 'DateTime', isNullable: false),
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains(
            'return result.map((k, v) => MapEntry(k, v.toIso8601String()));',
          ),
        );
      });
    });

    group('abstract method declarations', () {
      test('generates abstract method with no parameters', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'ping',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<bool>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'bool', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('Future<bool> ping();'));
        expect(code, contains('/// Override to implement: ping.'));
      });

      test('generates abstract method with positional parameters', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'greet',
              parameters: [
                ParsedParameter(
                  name: 'name',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('Future<String> greet(String name);'));
      });

      test('generates abstract method with named parameters with defaults', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'greet',
              parameters: [
                ParsedParameter(
                  name: 'name',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: false,
                  isNamed: true,
                  defaultValue: "'World'",
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(
          code,
          contains("Future<String> greet({String name = 'World'});"),
        );
      });

      test('includes documentation in abstract method', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'ping',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<bool>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'bool', isNullable: false),
                ],
              ),
              documentation: 'Returns true if the service is available.',
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('/// Returns true if the service is available.'));
        expect(code, contains('/// Override to implement: ping.'));
      });
    });

    group('helper methods generation', () {
      test('only generates helpers that are needed', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'greet',
              parameters: [
                ParsedParameter(
                  name: 'name',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<String>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'String', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('_requireString'));
        expect(code, isNot(contains('_requireInt')));
        expect(code, isNot(contains('_requireDouble')));
        expect(code, isNot(contains('_requireBool')));
      });

      test('generates multiple helpers when needed', () {
        final contract = ParsedServiceContract(
          className: 'TestService',
          namespace: 'test',
          methods: [
            ParsedMethod(
              name: 'process',
              parameters: [
                ParsedParameter(
                  name: 'name',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
                ParsedParameter(
                  name: 'count',
                  type: const ParsedType(displayName: 'int', isNullable: false),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<void>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'void', isNullable: false),
                ],
              ),
            ),
          ],
        );
        final code = generator.generate(contract);
        expect(code, contains('_requireString'));
        expect(code, contains('_requireInt'));
      });
    });

    group('full code generation', () {
      test('generates complete service for complex contract', () {
        final contract = ParsedServiceContract(
          className: 'WeatherService',
          namespace: 'weather',
          methods: [
            ParsedMethod(
              name: 'getCurrentWeather',
              parameters: [
                ParsedParameter(
                  name: 'city',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<WeatherInfo>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'WeatherInfo', isNullable: false),
                ],
              ),
              documentation: 'Gets current weather for the given city.',
            ),
            ParsedMethod(
              name: 'getForecast',
              parameters: [
                ParsedParameter(
                  name: 'city',
                  type: const ParsedType(
                    displayName: 'String',
                    isNullable: false,
                  ),
                  isRequired: true,
                  isNamed: false,
                ),
                ParsedParameter(
                  name: 'days',
                  type: const ParsedType(displayName: 'int', isNullable: false),
                  isRequired: false,
                  isNamed: true,
                  defaultValue: '5',
                ),
              ],
              returnType: const ParsedType(
                displayName: 'Future<List<WeatherForecast>>',
                isNullable: false,
                typeArguments: [
                  ParsedType(
                    displayName: 'List<WeatherForecast>',
                    isNullable: false,
                    typeArguments: [
                      ParsedType(
                        displayName: 'WeatherForecast',
                        isNullable: false,
                      ),
                    ],
                  ),
                ],
              ),
              documentation: 'Gets the 5-day forecast.',
            ),
            ParsedMethod(
              name: 'isAvailable',
              parameters: [],
              returnType: const ParsedType(
                displayName: 'Future<bool>',
                isNullable: false,
                typeArguments: [
                  ParsedType(displayName: 'bool', isNullable: false),
                ],
              ),
              documentation: 'Checks if the weather API is available.',
            ),
          ],
          documentation: 'Weather service contract.',
        );

        final code = generator.generate(contract);

        // Verify class declaration
        expect(
          code,
          contains('abstract class WeatherServiceBase extends FluttronService'),
        );

        // Verify namespace
        expect(code, contains("String get namespace => 'weather';"));

        // Verify switch cases
        expect(code, contains("case 'getCurrentWeather'"));
        expect(code, contains("case 'getForecast'"));
        expect(code, contains("case 'isAvailable'"));

        // Verify parameter extraction
        expect(code, contains("final city = _requireString(params, 'city');"));
        expect(
          code,
          contains(
            "final days = params['days'] == null ? 5 : params['days'] as int;",
          ),
        );

        // Verify abstract method declarations
        expect(
          code,
          contains('Future<WeatherInfo> getCurrentWeather(String city);'),
        );
        expect(
          code,
          contains(
            'Future<List<WeatherForecast>> getForecast(String city, {int days = 5});',
          ),
        );
        expect(code, contains('Future<bool> isAvailable();'));

        // Verify return serialization
        expect(code, contains('return result.toMap();'));
        expect(code, contains('return result.map((e) => e.toMap()).toList();'));
        expect(code, contains("return {'result': result};"));

        // Verify helper methods
        expect(code, contains('_requireString'));

        // Verify documentation
        expect(code, contains('/// Gets current weather for the given city.'));
        expect(code, contains('/// Gets the 5-day forecast.'));
        expect(code, contains('/// Checks if the weather API is available.'));
      });
    });
  });
}
