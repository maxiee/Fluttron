// GENERATED CODE â€” DO NOT MODIFY BY HAND
// Generated by: fluttron generate services
// Source: example_weather_contract.dart
// Timestamp: 2026-02-18T09:48:57.270590Z

import 'package:fluttron_host/fluttron_host.dart';
import 'package:fluttron_shared/fluttron_shared.dart';

/// Base class with routing logic.
/// Extend this class to provide method implementations.
abstract class WeatherServiceBase extends FluttronService {
  @override
  String get namespace => 'weather';

  @override
  Future<dynamic> handle(String method, Map<String, dynamic> params) async {
    switch (method) {
      case 'getCurrentWeather':
        final city = _requireString(params, 'city');
        final result = await getCurrentWeather(city);
        return result.toMap();

      case 'getForecast':
        final city = _requireString(params, 'city');
        final days = params['days'] == null ? 5 : params['days'] as int;
        final result = await getForecast(city, days: days);
        return result.map((e) => e.toMap()).toList();

      case 'isAvailable':
        final result = await isAvailable();
        return {'result': result};

      default:
        throw FluttronError(
          'METHOD_NOT_FOUND',
          'weather.$method not implemented',
        );
    }
  }

  /// Gets current weather for the given city.
  /// Override to implement: getCurrentWeather.
  Future<WeatherInfo> getCurrentWeather(String city);

  /// Gets the forecast for the given city.
  /// 
  /// [days] defaults to 5 if not specified.
  /// Override to implement: getForecast.
  Future<List<WeatherForecast>> getForecast(String city, {int days = 5});

  /// Checks if the weather API is available.
  /// Override to implement: isAvailable.
  Future<bool> isAvailable();

  String _requireString(Map<String, dynamic> params, String key) {
    final v = params[key];
    if (v is String && v.isNotEmpty) return v;
    throw FluttronError('BAD_PARAMS', 'Missing or invalid "$key"');
  }

}
